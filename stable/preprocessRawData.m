%     This file is part of the CoBaL code base
%     Copyright (C) 2017 Hendrik Reimann <hendrikreimann@gmail.com>
% 
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
% 
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
% 
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.

% this function applies several basic processing steps to experimental data, e.g. filtering

% input: 
% Experimental data files generated by importAscii.m, in the subfolder "raw"
%
% output: 
% multiple files with processed data for each trial, in the subfolder "processed"


function preprocessRawData(varargin)
    load('subjectInfo.mat');
    
    % parse arguments
    [condition_list, trial_number_list, calibration_trials, emg_trials] = parseTrialArguments(varargin{:});
    parser = inputParser;
    parser.KeepUnmatched = true;
    addParameter(parser, 'visualize', false)
    parse(parser, varargin{:})
    visualize = parser.Results.visualize;

    % add calibration and EMG trials if no specific condition was specified
    if ~isempty(calibration_trials)
        condition_list = [condition_list; 'calibration'];
        trial_number_list = [trial_number_list; calibration_trials];
    end
    if ~isempty(emg_trials)
        condition_list = [condition_list; 'emg'];
        trial_number_list = [trial_number_list; emg_trials];
    end
    
    % load settings
    study_settings_file = ['..' filesep 'studySettings.txt'];
    settings = loadSettingsFile(study_settings_file);

    %% emg
    data_dir = dir(['raw' filesep '*_emgTrajectoriesRaw.mat']);
    clear file_name_list;
    [file_name_list{1:length(data_dir)}] = deal(data_dir.name);
    number_of_files = length(file_name_list);
    for i_trial = 1 : number_of_files
        raw_emg_file_name = file_name_list{i_trial};
        [date, subject_id, trial_type, trial_number, file_type] = getFileParameters(raw_emg_file_name);

        % does the caller want to process this file?
        if any(strcmp(trial_type, condition_list))
            % condition is set to be processed, now check trial number
            trial_number_list_this_condition = trial_number_list{strcmp(trial_type, condition_list)};
            if ismember(trial_number, trial_number_list_this_condition)
                % process file
                load(['raw' filesep raw_emg_file_name]);

                % define filters
                % initial low pass filter
                filter_order_low = 4;
                cutoff_frequency_low = 500; % in Hz
                [b_low, a_low] = butter(filter_order_low, cutoff_frequency_low/(sampling_rate_emg/2), 'low');

                % high pass filter at 20 hz to get rid of DC offset
                filter_order_high = 4;
                cutoff_frequency_high = 20; % in Hz
                [b_high, a_high] = butter(filter_order_high, cutoff_frequency_high/(sampling_rate_emg/2), 'high');

                % low pass filter below 10 Hz -- aggressive smoothing after rectification
                filter_order_final = 4;
                cutoff_frequency_final = 10; % in Hz
                [b_final, a_final] = butter(filter_order_final, cutoff_frequency_high/(sampling_rate_emg/2), 'low');

                % filter, then rectify
                emg_trajectories_filtered_lowpass = filtfilt(b_low, a_low, emg_trajectories_raw);
                emg_trajectories_filtered_highpass = filtfilt(b_high, a_high, emg_trajectories_filtered_lowpass);
                emg_trajectories_rectified = abs(emg_trajectories_filtered_highpass);
                emg_trajectories = filtfilt(b_final, a_final, emg_trajectories_rectified);
                
                emg_labels_from_source = emg_labels;
                emg_labels = cell(size(emg_labels_from_source));
                for i_label = 1 : size(emg_labels_from_source, 2)
                    % find entry in emg_sensor_map
                    match_column = find(strcmp(emg_labels_from_source{i_label}, emg_sensor_map(1, :)));

                    if ~isempty(match_column)
                        emg_labels(i_label) = emg_sensor_map(2, match_column);
                    end
                end

                % save
                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'emgTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'emg_trajectories', ...
                    'time_emg', ...
                    'sampling_rate_emg', ...
                    'emg_labels' ...
                  );
                addAvailableVariable('emg_trajectories', 'time_emg', 'emg_labels', save_folder, save_file_name);
                disp(['filtered and saved as ' save_file_name])

                % visualize
                if visualize
                    i_channel = 1;
                    figure; axes; hold on; title(['EMG, condition ' trial_type ', trial ' num2str(trial_number)])
                    plot(time_emg, emg_trajectories_raw(:, i_channel), 'DisplayName', 'raw');
                    plot(time_emg, emg_trajectories_rectified(:, i_channel), 'DisplayName', 'rectified');
            %         plot(time_smoothed, rms_smoothed, 'DisplayName', 'rms smoothed', 'linewidth', 2);
            %         plot(time_emg, emg_trajectories_filtered_lowpass(:, i_channel), 'DisplayName', 'lowpass');
            %         plot(time_emg, emg_trajectories_filtered_highpass(:, i_channel), 'DisplayName', 'highpass');
                    plot(time_emg, emg_trajectories(:, i_channel), 'linewidth', 2, 'DisplayName', 'final');
                    legend('toggle');
                end                        


            end
        end
    end
    
    %% forceplate data
    data_dir = dir(['raw' filesep '*_forceplateTrajectoriesRaw.mat']);
    clear file_name_list;
    [file_name_list{1:length(data_dir)}] = deal(data_dir.name);
    number_of_files = length(file_name_list);
    for i_trial = 1 : number_of_files
        raw_forceplate_file_name = file_name_list{i_trial};
        [date, subject_id, trial_type, trial_number, file_type] = getFileParameters(raw_forceplate_file_name);
        
        % does the caller want to process this file?
        if any(strcmp(trial_type, condition_list))
            % condition is set to be processed, now check trial number
            trial_number_list_this_condition = trial_number_list{strcmp(trial_type, condition_list)};
            if ismember(trial_number, trial_number_list_this_condition)
        
        
                load(['raw' filesep raw_forceplate_file_name]);

                % define filter
                filter_order_low = 4;
                cutoff_frequency_low = 50; % in Hz
                [b_lowpass, a_lowpass] = butter(filter_order_low, cutoff_frequency_low/(sampling_rate_forceplate/2), 'low');
                forceplate_trajectories_filtered = filtfilt(b_lowpass, a_lowpass, forceplate_trajectories_raw);

                % extract
                fxl_trajectory = forceplate_trajectories_filtered(:, 1);
                fyl_trajectory = forceplate_trajectories_filtered(:, 2);
                fzl_trajectory = forceplate_trajectories_filtered(:, 3);
                mxl_trajectory = forceplate_trajectories_filtered(:, 4);
                myl_trajectory = forceplate_trajectories_filtered(:, 5);
                mzl_trajectory = forceplate_trajectories_filtered(:, 6);
                fxr_trajectory = forceplate_trajectories_filtered(:, 7);
                fyr_trajectory = forceplate_trajectories_filtered(:, 8);
                fzr_trajectory = forceplate_trajectories_filtered(:, 9);
                mxr_trajectory = forceplate_trajectories_filtered(:, 10);
                myr_trajectory = forceplate_trajectories_filtered(:, 11);
                mzr_trajectory = forceplate_trajectories_filtered(:, 12);

                % calculate CoP
                copxl_trajectory = - myl_trajectory ./ fzl_trajectory;
                copyl_trajectory = mxl_trajectory ./ fzl_trajectory;
                copxr_trajectory = - myr_trajectory ./ fzr_trajectory;
                copyr_trajectory = mxr_trajectory ./ fzr_trajectory;

                % zero CoP for no contact times
                fz_threshold = 60;
                copxl_trajectory(fzl_trajectory < fz_threshold) = 0;
                copyl_trajectory(fzl_trajectory < fz_threshold) = 0;
                copxr_trajectory(fzr_trajectory < fz_threshold) = 0;
                copyr_trajectory(fzr_trajectory < fz_threshold) = 0;

                if strcmp(data_source, 'nexus')
                    % transform forceplate data to CoBaL world frame A_cw
                    left_forceplate_wrench_Acl = [fxl_trajectory fyl_trajectory fzl_trajectory mxl_trajectory myl_trajectory mzl_trajectory];
                    left_forceplate_cop_Acl = [copxl_trajectory copyl_trajectory zeros(size(copxl_trajectory))];
                    right_forceplate_wrench_Acr = [fxr_trajectory fyr_trajectory fzr_trajectory mxr_trajectory myr_trajectory mzr_trajectory];
                    right_forceplate_cop_Acr = [copxr_trajectory copyr_trajectory zeros(size(copxr_trajectory))];

                    % define forceplate rotation and translation
                    Acr_to_world_rotation = [-1 0 0; 0 1 0; 0 0 -1];
                    Acr_to_world_translation = [0.5588; 0; 0];
                    Acr_to_world_trafo = [Acr_to_world_rotation Acr_to_world_translation; 0 0 0 1];
                    Acl_to_world_rotation = [-1 0 0; 0 1 0; 0 0 -1];
                    Acl_to_world_translation = [-0.5588; 0; 0];
                    Acl_to_world_trafo = [Acl_to_world_rotation Acl_to_world_translation; 0 0 0 1];
                    Acr_to_world_adjoint = rigidToAdjointTransformation(Acr_to_world_trafo);
                    Acl_to_world_adjoint = rigidToAdjointTransformation(Acl_to_world_trafo);

                    % transform
                    left_forceplate_wrench_world = (Acl_to_world_adjoint' * left_forceplate_wrench_Acl')';
                    left_forceplate_cop_world = (eye(2, 4) * Acl_to_world_trafo * [left_forceplate_cop_Acl ones(size(left_forceplate_cop_Acl, 1), 1)]')';
                    right_forceplate_wrench_world = (Acr_to_world_adjoint' * right_forceplate_wrench_Acr')';
                    right_forceplate_cop_world = (eye(2, 4) * Acr_to_world_trafo * [right_forceplate_cop_Acr ones(size(right_forceplate_cop_Acr, 1), 1)]')';
                elseif strcmp(data_source, 'neurocom')
                    left_forceplate_wrench_world = [fxl_trajectory fyl_trajectory fzl_trajectory mxl_trajectory myl_trajectory mzl_trajectory];
                    left_forceplate_cop_world = [copxl_trajectory copyl_trajectory zeros(size(copxl_trajectory))];
                    right_forceplate_wrench_world = [fxr_trajectory fyr_trajectory fzr_trajectory mxr_trajectory myr_trajectory mzr_trajectory];
                    right_forceplate_cop_world = [copxr_trajectory copyr_trajectory zeros(size(copxr_trajectory))];
                else
                    error(['data source "' data_source '" not recognized'])
                end

                % calculate wrenches and CoP for complete plate
                total_forceplate_wrench_world = left_forceplate_wrench_world + right_forceplate_wrench_world;
                copx_trajectory = - total_forceplate_wrench_world(:, 5) ./ total_forceplate_wrench_world(:, 3);
                copy_trajectory = total_forceplate_wrench_world(:, 4) ./ total_forceplate_wrench_world(:, 3);
                total_forceplate_cop_world = [copx_trajectory copy_trajectory];

                % re-zero CoP for low loads
                left_forceplate_low_load_indicator = (fzl_trajectory < fz_threshold);
                left_forceplate_cop_world(left_forceplate_low_load_indicator, :) = 0;
                right_forceplate_low_load_indicator = (fzr_trajectory < fz_threshold);
                right_forceplate_cop_world(right_forceplate_low_load_indicator, :) = 0;
                total_forceplate_low_load_indicator = (left_forceplate_low_load_indicator & right_forceplate_low_load_indicator);
                total_forceplate_cop_world(total_forceplate_low_load_indicator, :) = 0;


        %             % visualize
        %             figure; axes; hold on;
        %             plot(time_forceplate, total_forceplate_cop_world(:, 1), 'linewidth', 2, 'displayname', 'copx - total - calculated');
        %             plot(time_forceplate, left_forceplate_cop_world(:, 1), 'linewidth', 2, 'displayname', 'copx - left - calculated');
        %             plot(time_forceplate, right_forceplate_cop_world(:, 1), 'linewidth', 2, 'displayname', 'copx - right - calculated');
        %             plot(time_forceplate, forceplate_trajectories_filtered(:, 13), '--', 'linewidth', 2, 'displayname', 'copx - left - from plate');
        %             plot(time_forceplate, forceplate_trajectories_filtered(:, 15), '--', 'linewidth', 2, 'displayname', 'copx - right - from plate');
        %             plot(time_forceplate, forceplate_trajectories_filtered(:, 17), '--', 'linewidth', 2, 'displayname', 'copx - total - from plate');
        %             legend('toggle')
        %         
        %             figure; axes; hold on
        %             plot(time_forceplate, total_forceplate_cop_world(:, 2), 'linewidth', 2, 'displayname', 'copy - total - calculated');
        %             plot(time_forceplate, left_forceplate_cop_world(:, 2), 'linewidth', 2, 'displayname', 'copy - left - calculated');
        %             plot(time_forceplate, right_forceplate_cop_world(:, 2), 'linewidth', 2, 'displayname', 'copy - right - calculated');
        %             plot(time_forceplate, -forceplate_trajectories_filtered(:, 14), '--', 'linewidth', 2, 'displayname', 'copy - left - from plate - inverted');
        %             plot(time_forceplate, -forceplate_trajectories_filtered(:, 16), '--', 'linewidth', 2, 'displayname', 'copy - right - from plate - inverted');
        %             plot(time_forceplate, -forceplate_trajectories_filtered(:, 18), '--', 'linewidth', 2, 'displayname', 'copy - total - from plate - inverted');
        %             legend('toggle')

                % save
                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'forceplateTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'left_forceplate_wrench_world', ...
                    'left_forceplate_cop_world', ...
                    'right_forceplate_wrench_world', ...
                    'right_forceplate_cop_world', ...
                    'total_forceplate_wrench_world', ...
                    'total_forceplate_cop_world', ...
                    'fxl_trajectory', ...
                    'fyl_trajectory', ...
                    'fzl_trajectory', ...
                    'mxl_trajectory', ...
                    'myl_trajectory', ...
                    'mzl_trajectory', ...
                    'copxl_trajectory', ...
                    'copyl_trajectory', ...
                    'fxr_trajectory', ...
                    'fyr_trajectory', ...
                    'fzr_trajectory', ...
                    'mxr_trajectory', ...
                    'myr_trajectory', ...
                    'mzr_trajectory', ...
                    'copxr_trajectory', ...
                    'copyr_trajectory', ...
                    'time_forceplate', ...
                    'sampling_rate_forceplate' ...
                  );
                addAvailableVariable('left_forceplate_wrench_world', 'time_forceplate', 'left_forceplate_wrench_world', save_folder, save_file_name);
                addAvailableVariable('left_forceplate_cop_world', 'time_forceplate', 'left_forceplate_cop_world', save_folder, save_file_name);
                addAvailableVariable('right_forceplate_wrench_world', 'time_forceplate', 'right_forceplate_wrench_world', save_folder, save_file_name);
                addAvailableVariable('right_forceplate_cop_world', 'time_forceplate', 'right_forceplate_cop_world', save_folder, save_file_name);
                addAvailableVariable('total_forceplate_wrench_world', 'time_forceplate', 'total_forceplate_wrench_world', save_folder, save_file_name);
                addAvailableVariable('total_forceplate_cop_world', 'time_forceplate', 'total_forceplate_cop_world', save_folder, save_file_name);
                addAvailableVariable('fxl_trajectory', 'time_forceplate', 'fxl_trajectory', save_folder, save_file_name);
                addAvailableVariable('fyl_trajectory', 'time_forceplate', 'fyl_trajectory', save_folder, save_file_name);
                addAvailableVariable('fzl_trajectory', 'time_forceplate', 'fzl_trajectory', save_folder, save_file_name);
                addAvailableVariable('mxl_trajectory', 'time_forceplate', 'mxl_trajectory', save_folder, save_file_name);
                addAvailableVariable('myl_trajectory', 'time_forceplate', 'myl_trajectory', save_folder, save_file_name);
                addAvailableVariable('mzl_trajectory', 'time_forceplate', 'mzl_trajectory', save_folder, save_file_name);
                addAvailableVariable('copxl_trajectory', 'time_forceplate', 'copxl_trajectory', save_folder, save_file_name);
                addAvailableVariable('copyl_trajectory', 'time_forceplate', 'copyl_trajectory', save_folder, save_file_name);
                addAvailableVariable('fxr_trajectory', 'time_forceplate', 'fxr_trajectory', save_folder, save_file_name);
                addAvailableVariable('fyr_trajectory', 'time_forceplate', 'fyr_trajectory', save_folder, save_file_name);
                addAvailableVariable('fzr_trajectory', 'time_forceplate', 'fzr_trajectory', save_folder, save_file_name);
                addAvailableVariable('mxr_trajectory', 'time_forceplate', 'mxr_trajectory', save_folder, save_file_name);
                addAvailableVariable('myr_trajectory', 'time_forceplate', 'myr_trajectory', save_folder, save_file_name);
                addAvailableVariable('mzr_trajectory', 'time_forceplate', 'mzr_trajectory', save_folder, save_file_name);
                addAvailableVariable('copxr_trajectory', 'time_forceplate', 'copxr_trajectory', save_folder, save_file_name);
                addAvailableVariable('copyr_trajectory', 'time_forceplate', 'copyr_trajectory', save_folder, save_file_name);
                disp(['processed ' raw_forceplate_file_name ' and saved as ' [save_folder filesep save_file_name]])        
            end
        end
    end

    %% marker data
    data_dir = dir(['raw' filesep '*_markerTrajectoriesRaw.mat']);
    clear file_name_list;
    [file_name_list{1:length(data_dir)}] = deal(data_dir.name);
    number_of_files = length(file_name_list);
    for i_trial = 1 : number_of_files
        % load data
        raw_marker_file_name = file_name_list{i_trial};
        [date, subject_id, trial_type, trial_number, file_type] = getFileParameters(raw_marker_file_name);
        % does the caller want to process this file?
        if any(strcmp(trial_type, condition_list))
            % condition is set to be processed, now check trial number
            trial_number_list_this_condition = trial_number_list{strcmp(trial_type, condition_list)};
            if ismember(trial_number, trial_number_list_this_condition)
                load(['raw' filesep raw_marker_file_name]);

                % we're currently not doing anything, here
                marker_trajectories = marker_trajectories_raw;
                
                % save
                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'markerTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'marker_trajectories', ...
                    'time_mocap', ...
                    'sampling_rate_mocap', ...
                    'marker_labels' ...
                  );
                addAvailableVariable('marker_trajectories', 'time_mocap', 'marker_labels', save_folder, save_file_name);
                disp(['processed ' raw_marker_file_name ' and saved as ' save_file_name])        
            end
        end
    end

    %% transform to belt space
    for i_condition = 1 : length(condition_list)
        trials_to_process = trial_number_list{i_condition};
        for i_trial = trials_to_process
            % load data
            this_condition = condition_list{i_condition};
            if any(strcmp(settings.conditions_to_transform_to_belt_space, this_condition))
                % extract data for new structure
                if exist(['processed' filesep makeFileName(date, subject_id, trial_type, i_trial, 'plcData')], 'file')
                    load(['processed' filesep makeFileName(date, subject_id, trial_type, i_trial, 'plcData')])
                else
                    error(['Failed to load PLC data file for condition ' trial_type ', trial ' num2str(i_trial)]);
                end
                time_belts = time_plcData - time_plcData(1);

                % calculate shift
                belt_speed_trajectory = mean([belt_speed_left_trajectory belt_speed_right_trajectory], 2);
                delta_t = diff(time_belts);
                belt_position_trajectory_plcData = zeros(size(belt_speed_trajectory));
                for i_time = 2 : length(belt_speed_trajectory)
                    belt_position_trajectory_plcData(i_time) = belt_position_trajectory_plcData(i_time-1) + delta_t(i_time-1) * belt_speed_trajectory(i_time-1);
                end


                % apply shift to marker trajectories
                file_name_raw = ['raw' filesep makeFileName(date, subject_id, this_condition, i_trial, 'markerTrajectoriesRaw.mat')];
                load(file_name_raw);
                marker_trajectories = marker_trajectories_raw;
                belt_position_trajectory_mocap = spline(time_belts, belt_position_trajectory_plcData, time_mocap)';
                for i_marker = 1 : size(marker_headers, 2)
                    marker_trajectories(:, (i_marker-1)*3+2) = marker_trajectories(:, (i_marker-1)*3+2) + belt_position_trajectory_mocap;
                end
              
                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'markerTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'marker_trajectories', ...
                    'time_mocap', ...
                    'sampling_rate_mocap', ...
                    'marker_labels' ...
                  );
                addAvailableVariable('marker_trajectories', 'time_mocap', 'marker_labels', save_folder, save_file_name);
                disp(['Transformed marker data in ' file_name_raw ' to belt space and saved to ' file_name_shifted])                    
            end






%             % apply shift to forceplate trajectories
%             load(makeFileName(date, subject_id, condition, i_trial, 'forceplateTrajectories'));
%             belt_position_trajectory_forceplate = spline(time_belts, belt_position_trajectory_plcData, time_forceplate)';
%             
%             for i_time = 1 : length(time_forceplate)
%                 % define forceplate rotation and translation
%                 world_to_Acb_rotation = [1 0 0; 0 1 0; 0 0 1];
%                 world_to_Acb_translation = [0.5588; 0; 0];
%                 world_to_Acb_trafo = [world_to_Acb_rotation world_to_Acb_translation; 0 0 0 1];
%                 world_to_Acb_adjoint = rigidToAdjointTransformation(world_to_Acb_trafo);
% 
%                 % transform
%                 left_forceplate_wrench_Acb = (world_to_Acb_adjoint' * left_forceplate_wrench_world')';
%                 right_forceplate_wrench_Acb = (world_to_Acb_adjoint' * right_forceplate_wrench_world')';
% 
%             end
% 
%             % calculate wrenches and CoP for complete plate
%             total_forceplate_wrench_Acb = left_forceplate_wrench_Acb + right_forceplate_wrench_Acb;
%             copx_trajectory = - total_forceplate_wrench_Acb(:, 5) ./ total_forceplate_wrench_Acb(:, 3);
%             copy_trajectory = total_forceplate_wrench_Acb(:, 4) ./ total_forceplate_wrench_Acb(:, 3);
%             total_forceplate_cop_Acb = [copx_trajectory copy_trajectory];
%                 
%             % re-zero CoP for low loads
%             left_forceplate_low_load_indicator = copxl_trajectory == 0;
%             left_forceplate_cop_world(left_forceplate_low_load_indicator, :) = 0;
%             right_forceplate_low_load_indicator = copxr_trajectory == 0;
%             right_forceplate_cop_world(right_forceplate_low_load_indicator, :) = 0;
%             total_forceplate_low_load_indicator = copx_trajectory == 0;
%             total_forceplate_cop_world(total_forceplate_low_load_indicator, :) = 0;            

        end
    end

    
    


    
    
    
    
    
    
    
    
end