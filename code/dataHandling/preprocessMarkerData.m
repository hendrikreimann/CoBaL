%     This file is part of the CoBaL code base
%     Copyright (C) 2017 Hendrik Reimann <hendrikreimann@gmail.com>
% 
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
% 
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
% 
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.

% this function applies several basic processing steps to experimental data, e.g. filtering

% input: 
% Experimental data files generated by importAscii.m, in the subfolder "raw"
%
% output: 
% multiple files with processed data for each trial, in the subfolder "processed"


function preprocessMarkerData(varargin)
    % parse arguments
    [types_to_analyze, trials_to_analyze, types_to_exclude, trials_to_exclude] = parseTrialArguments(varargin{:});
    parser = inputParser;
    parser.KeepUnmatched = true;
    addParameter(parser, 'type', 'all')
    addParameter(parser, 'visualize', false)
    parse(parser, varargin{:})
    visualize = parser.Results.visualize;
    
    subject_info = load('subjectInfo.mat');

    % add excluded trials back in, because while we don't want to analyze them, we still want to pre-process them
    types_to_analyze = [types_to_analyze; types_to_exclude];
    trials_to_analyze = [trials_to_analyze; trials_to_exclude];
    
    % load settings
    study_settings_file = '';
    if exist(['..' filesep 'studySettings.txt'], 'file')
        study_settings_file = ['..' filesep 'studySettings.txt'];
    end    
    if exist(['..' filesep '..' filesep 'studySettings.txt'], 'file')
        study_settings_file = ['..' filesep '..' filesep 'studySettings.txt'];
    end
    study_settings = SettingsCustodian(study_settings_file);
    subject_settings = SettingsCustodian('subjectSettings.txt');
    
    % load static reference trial
    load(['raw' filesep makeFileName(subject_info.date, subject_info.subject_id, subject_settings.get('static_reference_trial_type'), subject_settings.get('static_reference_trial_number'), 'markerTrajectoriesRaw.mat')]);
    marker_labels_reference = marker_labels;
    marker_directions_reference = marker_directions;


    data_dir = dir(['raw' filesep '*_markerTrajectoriesRaw.mat']);
    clear file_name_list;
    [file_name_list{1:length(data_dir)}] = deal(data_dir.name);
    number_of_files = length(file_name_list);
    for i_trial = 1 : number_of_files
        % load data
        raw_marker_file_name = file_name_list{i_trial};
        [date, subject_id, trial_type, trial_number] = getFileParameters(raw_marker_file_name);
        % does the caller want to process this file?
        if any(strcmp(trial_type, types_to_analyze))
            % condition is set to be processed, now check trial number
            trial_number_list_this_condition = trials_to_analyze{strcmp(trial_type, types_to_analyze)};
            if ismember(trial_number, trial_number_list_this_condition)
                load(['raw' filesep raw_marker_file_name]);

                if study_settings.get('filter_marker_data')
                    filter_order = 4;
                    cutoff_frequency = study_settings.get('marker_data_cutoff_frequency'); % in Hz
                    [b_marker, a_marker] = butter(filter_order, cutoff_frequency/(sampling_rate_mocap/2));
                    marker_trajectories = nanfiltfilt(b_marker, a_marker, marker_trajectories_raw);
                else
                    marker_trajectories = marker_trajectories_raw;
                end


                % compare marker labels to reference trial
                marker_labels_equal = 0;
                if length(marker_labels) == length(marker_labels_reference)
                    marker_labels_equal = 1;
                    % length is the same, now compare individual labels
                    for i_label = 1 : length(marker_labels_reference)
                        if ~strcmp(marker_labels{i_label}, marker_labels_reference{i_label})
                            marker_labels_equal = 0;
                        end
                    end
                end

                if ~marker_labels_equal
                    marker_trajectories_unsorted = marker_trajectories;
                    marker_labels_unsorted = marker_labels;
                    marker_trajectories = zeros(size(marker_trajectories, 1), length(marker_labels_reference)) * NaN;
                    marker_labels = marker_labels_reference;
                    marker_directions = marker_directions_reference;

                    for i_label = 1 : length(marker_labels_reference)
                        this_label = marker_labels{i_label};
                        this_label_index = find(strcmp(marker_labels_unsorted, this_label));
                        if ~isempty(this_label_index)
                            marker_trajectories(:, i_label) = marker_trajectories_unsorted(:, this_label_index);
                        end
                    end
                end


                % save
                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'markerTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'marker_trajectories', ...
                    'time_mocap', ...
                    'sampling_rate_mocap', ...
                    'marker_labels',  ...
                    'marker_directions' ...
                  );
                addAvailableData ...
                  ( ...
                    'marker_trajectories', ...
                    'time_mocap', ...
                    'sampling_rate_mocap', ...
                    '_marker_labels', ...
                    '_marker_directions', ...
                    save_folder, ...
                    save_file_name ...
                  );
%                     addAvailableData('marker_trajectories', 'time_mocap', 'sampling_rate_mocap', 'marker_labels', save_folder, save_file_name);
                disp(['processed ' raw_marker_file_name ' and saved as ' save_file_name])
            end
        end
    end

    %% transform to belt space
    for i_condition = 1 : length(types_to_analyze)
        trials_to_process = trials_to_analyze{i_condition};
        for i_trial = trials_to_process
            % load data
            this_condition = types_to_analyze{i_condition};
            if any(strcmp(study_settings.get('conditions_to_transform_to_belt_space', 1), this_condition))
                % extract data for new structure
                if exist(['processed' filesep makeFileName(date, subject_id, trial_type, i_trial, 'plcData')], 'file')
                    load(['processed' filesep makeFileName(date, subject_id, trial_type, i_trial, 'plcData')])
                else
                    error(['Failed to load PLC data file for condition ' trial_type ', trial ' num2str(i_trial)]);
                end
                time_belts = time_plcData - time_plcData(1);

                % calculate shift
                belt_speed_trajectory = mean([belt_speed_left_trajectory belt_speed_right_trajectory], 2);
                delta_t = diff(time_belts);
                belt_position_trajectory_plcData = zeros(size(belt_speed_trajectory));
                for i_time = 2 : length(belt_speed_trajectory)
                    belt_position_trajectory_plcData(i_time) = belt_position_trajectory_plcData(i_time-1) + delta_t(i_time-1) * belt_speed_trajectory(i_time-1);
                end

                % apply shift to marker trajectories
                file_name_raw = ['raw' filesep makeFileName(date, subject_id, this_condition, i_trial, 'markerTrajectoriesRaw.mat')];
                load(file_name_raw);
                marker_trajectories = marker_trajectories_raw;
                belt_position_trajectory_mocap = spline(time_belts, belt_position_trajectory_plcData, time_mocap)';
                for i_marker = 1 : size(marker_headers, 2)
                    marker_trajectories(:, (i_marker-1)*3+2) = marker_trajectories(:, (i_marker-1)*3+2) + belt_position_trajectory_mocap;
                end

                save_folder = 'processed';
                save_file_name = makeFileName(date, subject_id, trial_type, trial_number, 'markerTrajectories.mat');
                save ...
                  ( ...
                    [save_folder filesep save_file_name], ...
                    'marker_trajectories', ...
                    'time_mocap', ...
                    'sampling_rate_mocap', ...
                    'marker_labels' ...
                  );
                addAvailableData('marker_trajectories', 'time_mocap', 'marker_labels', save_folder, save_file_name);
                disp(['Transformed marker data in ' file_name_raw ' to belt space and saved to ' file_name_shifted])                    
            end






%             % apply shift to forceplate trajectories
%             load(makeFileName(date, subject_id, condition, i_trial, 'forceplateTrajectories'));
%             belt_position_trajectory_forceplate = spline(time_belts, belt_position_trajectory_plcData, time_forceplate)';
%             
%             for i_time = 1 : length(time_forceplate)
%                 % define forceplate rotation and translation
%                 world_to_Acb_rotation = [1 0 0; 0 1 0; 0 0 1];
%                 world_to_Acb_translation = [0.5588; 0; 0];
%                 world_to_Acb_trafo = [world_to_Acb_rotation world_to_Acb_translation; 0 0 0 1];
%                 world_to_Acb_adjoint = rigidToAdjointTransformation(world_to_Acb_trafo);
% 
%                 % transform
%                 left_forceplate_wrench_Acb = (world_to_Acb_adjoint' * left_forceplate_wrench_world')';
%                 right_forceplate_wrench_Acb = (world_to_Acb_adjoint' * right_forceplate_wrench_world')';
% 
%             end
% 
%             % calculate wrenches and CoP for complete plate
%             total_forceplate_wrench_Acb = left_forceplate_wrench_Acb + right_forceplate_wrench_Acb;
%             copx_trajectory = - total_forceplate_wrench_Acb(:, 5) ./ total_forceplate_wrench_Acb(:, 3);
%             copy_trajectory = total_forceplate_wrench_Acb(:, 4) ./ total_forceplate_wrench_Acb(:, 3);
%             total_forceplate_cop_Acb = [copx_trajectory copy_trajectory];
%                 
%             % re-zero CoP for low loads
%             left_forceplate_low_load_indicator = copxl_trajectory == 0;
%             left_forceplate_cop_world(left_forceplate_low_load_indicator, :) = 0;
%             right_forceplate_low_load_indicator = copxr_trajectory == 0;
%             right_forceplate_cop_world(right_forceplate_low_load_indicator, :) = 0;
%             total_forceplate_low_load_indicator = copx_trajectory == 0;
%             total_forceplate_cop_world(total_forceplate_low_load_indicator, :) = 0;            

        end
    end
end
    
    