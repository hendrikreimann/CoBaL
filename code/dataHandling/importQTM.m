%     This file is part of the CoBaL code base
%     Copyright (C) 2017 Hendrik Reimann <hendrikreimann@gmail.com>
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.

% this script transform raw data from ascii into matlab format

% input:
% Experimental data files generated by e.g. Nexus, QTM, labview etc.
% Files are expected to be in subfolders named <subject code>_<source type>, e.g. XYZ_labview
% any source type is viable, but if it is not in the default list, it must be specified as a name-value pair,
% e.g. importAscii('sources', 'someSource') would look for data in the subfolder XYZ_someSource
%
% output:
% Files containing the same data in .mat format, with some additional information about where they came from.
% Output files will be saved to folders "raw" and "processed".

function importQTM(varargin)
    % parse arguments
    parser = inputParser;
    parser.KeepUnmatched = true;
    addParameter(parser, 'visualize', true)
    addParameter(parser, 'file', '')
    parse(parser, varargin{:})
    options.visualize = parser.Results.visualize;
    options.file = parser.Results.file;

    %% prepare
    % set some parameters
    options.millimeter_to_meter = 1e-3;

    study_settings = loadSettingsFromFile('study');
    subject_settings = loadSettingsFromFile('subject');
    options.import_mode = study_settings.get('qtm_import_mode', 1);
    if subject_settings.isfield('qtm_import_mode')
        import_mode_from_subject = subject_settings.get('qtm_import_mode', 1);
        if ~isequal(options.import_mode, import_mode_from_subject)
            options.import_mode = import_mode_from_subject;
            disp(['Using import mode "' import_mode_from_subject '" from subjectSettings.txt'])
        end
    end    
    % qtm_import_mode determines how the data in the QTM files are cut into pieces and mapped onto trials accoding to
    % the labview protocol file | ATTENTION: mode 3. and 4. are currently the only ones that works, the other ones will
    % have to be updated to generate a trial table from the available information
    % 1. encoded -- analog signal, increasing edge signals switch to a new step in protocol file -- currently not working
    % 2. table -- analog signal, increasing edge signals switch to new trial in table in subject settings -- currently not working 
    % 3. events -- QTM events signal start/stop of trials, info is stored as event label
    % 4. bijective -- each QTM file is mapped to a labview trial with trial type and number from the QTM file name -- currently not working 

%     analog_to_protocol_mapping = subject_settings.get('analog_to_protocol_mapping', 1);

    % create folders if necessary
    if ~directoryExists('raw')
        mkdir('raw')
    end
    if ~directoryExists('processed')
        mkdir('processed')
    end
    if ~directoryExists('analysis')
        mkdir('analysis')
    end
    options.qtm_source_dir = 'qtm';
    
    % load protocol file if available
    if exist('protocolInfo.mat', 'file')
        options.protocol_file_available = 1;
        options.protocol_info = load('protocolInfo.mat');
    else
        options.protocol_file_available = 0;
    end

    %% import data
    if isempty(options.file)
        data_dir_mat = dir([options.qtm_source_dir filesep '*mat']);
        [file_name_list{1:length(data_dir_mat)}] = deal(data_dir_mat.name);
    else
        file_name_list = {options.file};
    end

    % go through QTM files and import
    number_of_files = length(file_name_list);
    for i_file = 1 : number_of_files
        
        data_file_name = file_name_list{i_file};
        importSingleQtmFile(data_file_name, options, study_settings, subject_settings);
    end

end

function importSingleQtmFile(data_file_name, options, study_settings, subject_settings)

    disp(['Importing ' options.qtm_source_dir filesep data_file_name])

    % file info
    file_info = struct;
    [file_info.collection_date, file_info.subject_id, file_info.trial_type, file_info.trial_number] ...
        = getFileParameters(data_file_name);

    % load QTM data from file
    var_name = whos('-file', [options.qtm_source_dir, filesep, data_file_name]);
    temp_data = load([options.qtm_source_dir, filesep, data_file_name]);
    qtm_data = temp_data.(var_name.name);

    % determine trial table
    trial_table = determineTrialTable(qtm_data, file_info, options);
    
    % import data according to trial table
    for i_trial = 1 : size(trial_table, 1)
        % get info from table
        trial_info.start_time = trial_table{i_trial, 'start_time'};
        trial_info.end_time = trial_table{i_trial, 'end_time'};
        trial_info.start_frame = trial_table{i_trial, 'start_frame'};
        trial_info.end_frame = trial_table{i_trial, 'end_frame'};
        trial_info.trial_type = trial_table{i_trial, 'trial_type'};
        trial_info.trial_number = trial_table{i_trial, 'trial_number'};
        
        % import data
        importTrialDataAnalog(qtm_data, trial_info, file_info, study_settings, subject_settings);
        importTrialDataForceplate(qtm_data, trial_info, file_info, study_settings, options);
        importTrialDataMarker(qtm_data, trial_info, file_info, study_settings, subject_settings, options);
        
        % report to command window
        this_trial_length = trial_info.end_time - trial_info.start_time;
        disp( ...
          [ ...
            '  Saved data files for type ' char(trial_info.trial_type) ...
            ', trial ' num2str(trial_info.trial_number) ...
            ' with duration ' num2str(this_trial_length) ...
            's (' num2str(trial_info.start_time) ...
            '-' num2str(trial_info.end_time) ...
            ')' ...
          ] ...
        )
    end
end

function trial_table = determineTrialTable(qtm_data, file_info, options)
    % initialize flags
    import_whole_trial = false;
    
    % prepare trial table
    trial_table_variable_names = {'start_time', 'end_time', 'start_frame', 'end_frame', 'trial_type', 'trial_number'};
    trial_table_variable_types = {'double', 'double', 'double', 'double', 'string', 'string'};
    trial_table = table ...
      ( ...
        'Size', [0, 6], ...
        'VariableNames', trial_table_variable_names, ...
        'VariableTypes', trial_table_variable_types ...
      );
    
    if strcmp(options.import_mode, 'events')
        % process events in this data file
        events = qtm_data.Events;
        event_times = [events(:).Time]';
        event_frames = [events(:).Frame]';
        event_labels = {events(:).Label}';
        event_labels_type = cell(size(events));
        event_labels_number = cell(size(events));
        event_labels_suffix = cell(size(events));
        for i_event = 1 : length(events)
            this_event_label = event_labels{i_event};
            this_event_label_split = strsplit(this_event_label, '_');
            event_labels_type{i_event} = this_event_label_split{1};
            event_labels_number{i_event} = this_event_label_split{2};
            event_labels_suffix{i_event} = this_event_label_split{3};
        end
        disp(['  found ' num2str(length(events)) ' events']);
        if (isempty(events))
            if (strcmp(file_info.trial_type, 'static')) || (strcmp(file_info.trial_type, 'calibration'))
                disp(['  trial type: ' file_info.trial_type ' - importing whole trial'])
                import_whole_trial = true;
            else
                disp(' no data will be imported')
            end
        end
        
        % collect event info in table
        event_table_variable_names = {'time', 'frame', 'type', 'number', 'suffix'};
        event_table_variable_types = {'double', 'double', 'string', 'string', 'string'};
        event_table = table ...
          ( ...
            'Size', [length(events), 5], ...
            'VariableNames', event_table_variable_names, ...
            'VariableTypes', event_table_variable_types ...
          );
        event_table.time = event_times;
        event_table.frame = event_frames;
        for i_event = 1 : length(events)
            this_event_label = event_labels{i_event};
            this_event_label_split = strsplit(this_event_label, '_');
            event_table(i_event, 'type') = this_event_label_split(1);
            event_table(i_event, 'number') = this_event_label_split(2);
            event_table(i_event, 'suffix') = this_event_label_split(3);
        end
        
        % re-structure events to combine start and end
        discarded_events = table;
        while size(event_table, 1) > 0
            if size(event_table, 1) == 1
                % if there is only a single event left, discard it
                discarded_events = [discarded_events; event_table(1, :)]; %#ok<AGROW>
                event_table(1, :) = [];
            else
                % check if first two events are a fit
                if strcmp(event_table{1, 'suffix'}, 'start') && strcmp(event_table{2, 'suffix'}, 'end') ...
                        && strcmp(event_table{1, 'number'}, event_table{2, 'number'}) ...
                        && strcmp(event_table{1, 'type'}, event_table{2, 'type'})
                    % we have a fit, import the first two events
                    this_event_start_time = event_table{1, 'time'};
                    this_event_end_time = event_table{2, 'time'};
                    this_event_start_frame = event_table{1, 'frame'};
                    this_event_end_frame = event_table{2, 'frame'};
                    this_event_trial_type = event_table{1, 'type'};
                    this_event_trial_number = event_table{1, 'number'};
                    this_trial_data = ...
                      { ...
                        this_event_start_time, ...
                        this_event_end_time, ...
                        this_event_start_frame, ...
                        this_event_end_frame, ...
                        this_event_trial_type, ...
                        this_event_trial_number ...
                      };
                    trial_table = [trial_table; this_trial_data]; %#ok<AGROW>
                    
                    % remove imported events from event table
                    event_table([1 2], :) = [];
                else
                    % no fit, discard first event in the table
                    discarded_events = [discarded_events; event_table(1, :)]; %#ok<AGROW>
                    event_table(1, :) = [];
                end
                
            end
            
            
            
        end
        if size(discarded_events, 1) > 0
            disp('Warning: Could not fully resolve events. Discarded events:')
            disp(discarded_events);
        end
    end
    
    if strcmp(options.import_mode, 'encoded')
        % this is a legacy mode that hasn't been tested after updating code structure
        if (strcmp(file_info.trial_type, 'static')) || (strcmp(file_info.trial_type, 'calibration'))
            disp(['  trial type: ' file_info.trial_type ' - importing whole trial'])
            import_whole_trial = true;
        else
            % break up into chunks for trials
            trigger_mask = contains(qtm_data.Analog.Labels, 'labview_sync');
            trigger = qtm_data.Analog.Data(trigger_mask,:);
            % normalise to the range [0,1] and round
            trigger = round(trigger/max(trigger));

            % find edges
            trigger_edges = [diff(trigger), 0];
            analog_indices = 1:length(qtm_data.Analog.Data);
            start_indices_analog = analog_indices(trigger_edges == -1); % trials start on negative edge
            end_indices_analog = analog_indices(trigger_edges == 1); % trials end on positive edge
            time_analog = (1 : qtm_data.Analog.NrOfSamples)' / qtm_data.Analog.Frequency;

            % figure out protocol steps
            protocol_step_mask = contains(qtm_data.Analog.Labels, 'currentStep');
            protocol_step_analog = qtm_data.Analog.Data(protocol_step_mask,:);
%             protocol_step_up_indices = find([diff(protocol_step_analog), 0] > 0.08);

            if isempty(start_indices_analog) && isempty(end_indices_analog)
%                 start_indices_analog = 1;
%                 end_indices_analog = length(analog_indices);
                disp(['  trial type: ' file_info.trial_type ' - importing whole trial'])
                import_whole_trial = true;
                % HR 2021-03-29: adding back legacy code to process Vision Amplitude data, not sure if this part works
            end

            % check whether each start index has a matching end index
            for i_start_index = 1 : length(start_indices_analog)
                % remove end indices that come before the start index - HR: not sure whether this part is needed
                while length(end_indices_analog) >= i_start_index && end_indices_analog(i_start_index) <= start_indices_analog(i_start_index)
                    end_indices_analog(i_start_index) = [];
                end
            end
            if length(end_indices_analog) > length(start_indices_analog)
                disp('More end indices than start indices, removing superfluous ones')
                end_indices_analog(length(start_indices_analog)+1 : end) = [];
            end
            if length(start_indices_analog) > length(end_indices_analog)
                disp('More start indices than end indices, removing superfluous ones')
                start_indices_analog(length(end_indices_analog)+1 : end) = [];
            end
            if end_indices_analog(end) > length(qtm_data.Analog.Data)
                end_indices_analog(end) = length(qtm_data.Analog.Data);
            end

            % provide visual feedback if desired
            if options.visualize
                figure; this_file_axes = axes; hold on;
                plot(this_file_axes, time_analog, protocol_step_analog, 'color', [1 1 1]*0.7);
%                 plot(time_analog(protocol_step_up_indices), protocol_step_analog(protocol_step_up_indices), '^');
%                 plot(time_analog(start_indices_analog), protocol_step_analog(start_indices_analog), '>');
%                 plot(time_analog(end_indices_analog), protocol_step_analog(end_indices_analog), '<');
                xlabel('time (s)');
                ylabel('protocol step analog (mV?)');
                xlim([time_analog(1) time_analog(end)]);
                drawnow
                
                step_colors = parula(length(start_indices_analog));
            end
            
            % reorganize info into table
            if ~options.protocol_file_available
                error('Failed to load protocolInfo.mat. Please run importProtocolData to import labview/protocol.csv if available.')
            end
            for i_trial = 1 : length(start_indices_analog)
                this_trial_start_index = start_indices_analog(i_trial);
                this_trial_end_index = end_indices_analog(i_trial);
            
                % figure out protocol step from the analog signal
                this_trial_protocol_step_analog = protocol_step_analog(this_trial_start_index:this_trial_end_index);

                analog_to_step_range = (-10 : 0.1 : 10)';
                offset = analogOffset();
                this_trial_offset = interp1(analog_to_step_range, offset, this_trial_protocol_step_analog);
                this_trial_protocol_step_analog_corrected = this_trial_protocol_step_analog + this_trial_offset;

                % discrete map from [-10 10] --> [0 200]
                this_trial_protocol_step_digital = round((this_trial_protocol_step_analog_corrected + 10) * 10);
                this_trial_protocol_step = median(this_trial_protocol_step_digital);

                if sum(this_trial_protocol_step_digital(2:end-1)~=median(this_trial_protocol_step_digital)) > 20
                    protocol_step_ambiguous = 1;
                    warning(['Found ambiguous protocol step data, for trial starting at ' num2str(time_analog(this_trial_start_index)) ' s']);
                else
                    protocol_step_ambiguous = 0;
                end
                this_trial_protocol_index = median(this_trial_protocol_step) + 1;
                importing_trial_type = options.protocol_info.trial_type{this_trial_protocol_index};
                importing_trial_number = options.protocol_info.trial_number(this_trial_protocol_index);
                this_trial_length_expected = options.protocol_info.trial_duration(this_trial_protocol_index);           

                % add trial to table
                this_trial_start_time = time_analog(this_trial_start_index);
                this_trial_end_time = time_analog(this_trial_end_index);
                this_trial_start_frame = ceil(this_trial_start_index / qtm_data.Analog.SamplingFactor);
                this_trial_end_frame = ceil(this_trial_end_index / qtm_data.Analog.SamplingFactor);
                this_trial_data = ...
                  { ...
                    this_trial_start_time, ...
                    this_trial_end_time, ...
                    this_trial_start_frame, ...
                    this_trial_end_frame, ...
                    importing_trial_type, ...
                    importing_trial_number ...
                  };
                trial_table = [trial_table; this_trial_data]; %#ok<AGROW>

                % check whether the actual trial length is within +- 1% of the expected value based on the protocol file
                this_trial_length = this_trial_end_time - this_trial_start_time;
                if this_trial_length < this_trial_length_expected*0.99 || this_trial_length > this_trial_length_expected*1.01
                    warning ...
                      ( ...
                        [ ...
                          'Problem with trial starting at time step ' ...
                          num2str(this_trial_start_index) ...
                          ', expected duration is ' ...
                          num2str(this_trial_length_expected) ...
                          's, but data is ' ...
                          num2str(this_trial_length) ...
                          's long.' ...
                        ] ...
                      );
                end
                
                % add mark to visualization
                if options.visualize
                    this_color = step_colors(i_trial, :);
                    
                    this_label = [importing_trial_type ' ' num2str(importing_trial_number)];
                    if protocol_step_ambiguous
                        this_label = ['*** ' this_label ' ***']; %#ok<AGROW>
                    end
                    
                    this_trial_protocol_step_analog_median = median(this_trial_protocol_step_analog);
                    plot ...
                      ( ...
                        this_file_axes, ...
                        [this_trial_start_time, this_trial_end_time], ...
                        this_trial_protocol_step_analog_median*[1 1], ...
                        'linewidth', 4, ...
                        'color', this_color ...
                      )
                    text ...
                      ( ...
                        this_file_axes, ...
                        (this_trial_start_time + this_trial_end_time)*0.5, ...
                        this_trial_protocol_step_analog_median, ...
                        this_label, ...
                        'color', this_color, ...
                        'FontWeight', 'bold', ...
                        'HorizontalAlignment', 'center', ...
                        'VerticalAlignment', 'top', ...
                        'Fontsize', 14 ...
                      )
                    drawnow
                end
            end




            
            
            
        end
        
    end
    
    if strcmp(options.import_mode, 'table')
        % TODO: this is a legacy mode that's not in use anymore. When separating the labview data import from
        % this function, I did not make sure that this keeps working. To make it work again, you will probably
        % load information from protocolInfo.mat and maybe others.
%             if ~protocol_file_available
%                 error('Failed to locate protocol.csv in the labview folder, exiting.')
%             end
%             trial_type_matches = strcmp(analog_to_protocol_mapping(:, 1), trial_type);
%             trial_number_matches = strcmp(analog_to_protocol_mapping(:, 2), num2str(trial_number));
%             index_number_matches = strcmp(analog_to_protocol_mapping(:, 3), num2str(i_trial_this_qtm_file));
%             this_trial_protocol_index = str2double(analog_to_protocol_mapping{trial_type_matches & trial_number_matches & index_number_matches, 4});
%             importing_trial_type = protocol_trial_type{this_trial_protocol_index};
%             importing_trial_number = protocol_trial_number(this_trial_protocol_index);
%             this_trial_length_expected = protocol_trial_duration(this_trial_protocol_index);           
%             save_this_trial = protocol_trial_saved(this_trial_protocol_index);
    end

    if strcmp(options.import_mode, 'bijective')
        import_whole_trial = 1;
    end
    
    if import_whole_trial
        trial_start_time = qtm_data.StartFrame / qtm_data.FrameRate;
        trial_end_time = (qtm_data.Frames - qtm_data.StartFrame + 1) / qtm_data.FrameRate;
        this_trial_data = ...
          { ...
            trial_start_time, ...
            trial_end_time, ...
            qtm_data.StartFrame, ...
            qtm_data.Frames, ...
            file_info.trial_type, ...
            file_info.trial_number...
          };
        trial_table = [trial_table; this_trial_data];
    end
end

function importTrialDataAnalog(qtm_data, trial_info, file_info, study_settings, subject_settings)
    analog_data_is_available = isfield(qtm_data, 'Analog');
    if analog_data_is_available
        % find columns to import
        analog_data_to_import = study_settings.get('analog_data_to_import', 1);
        number_of_analog_channels_to_import = length(analog_data_to_import);
        
        % import analog data (non-emg)
        if number_of_analog_channels_to_import > 0
            % find index of first and last frame to import
            first_frame_to_import = round(trial_info.start_frame * qtm_data.Analog.SamplingFactor);
            last_frame_to_import = round(trial_info.end_frame * qtm_data.Analog.SamplingFactor);
            
            % make time array for this trial
            sampling_rate_analog = qtm_data.Analog.Frequency;
            number_of_samples = last_frame_to_import - first_frame_to_import + 1;
            time_analog = (1 : number_of_samples) / sampling_rate_analog;
            
            % extract data
            analog_trajectories = zeros(number_of_samples, number_of_analog_channels_to_import);
            for i_channel = 1 : number_of_analog_channels_to_import
                index_in_loaded_data = strcmp(qtm_data.Analog.Labels, analog_data_to_import(i_channel));
                analog_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, first_frame_to_import:last_frame_to_import)';
            end

            % make directions
            analog_directions = cell(2, length(analog_data_to_import));
            [analog_directions{1, :}] = deal('positive');
            [analog_directions{2, :}] = deal('negative');

            % save analog data
            analog_labels = analog_data_to_import;
            save_folder = 'processed';
            save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'analogTrajectories.mat');
            save ...
                ( ...
                [save_folder filesep save_file_name], ...
                'analog_trajectories', ...
                'time_analog', ...
                'sampling_rate_analog', ...
                'analog_labels', ...
                'analog_directions' ...
                );
            addAvailableData('analog_trajectories', 'time_analog', 'sampling_rate_analog', '_analog_labels', '_analog_directions', save_folder, save_file_name);
        end

        % import emg data
        emg_import_map_header = subject_settings.get('emg_import_map_header', 1);
        emg_import_map = subject_settings.get('emg_import_map', 1);

        import_emg_data = 1;
        if isempty(emg_import_map)
            import_emg_data = 0;
        else
            emg_data_to_import = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_qtm_file'));
            number_of_emg_channels_to_import = length(emg_data_to_import);
            if number_of_emg_channels_to_import == 0
                import_emg_data = 0;
            end
        end

        if import_emg_data
            % find index of first and last frame to import
            first_frame_to_import = round(trial_info.start_frame * qtm_data.Analog.SamplingFactor);
            last_frame_to_import = round(trial_info.end_frame * qtm_data.Analog.SamplingFactor);
            
            % make time array for this trial
            sampling_rate_emg = qtm_data.Analog.Frequency;
            number_of_samples = last_frame_to_import - first_frame_to_import + 1;
            time_emg = (1 : number_of_samples) / sampling_rate_emg;
            
            % EMG
            emg_labels = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_cobal'))';
            emg_raw_trajectories = zeros(number_of_samples, number_of_emg_channels_to_import);
            for i_channel = 1 : number_of_emg_channels_to_import
                index_in_loaded_data = strcmp(qtm_data.Analog.Labels, emg_data_to_import(i_channel));
                emg_raw_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, first_frame_to_import:last_frame_to_import)';
            end

            % make directions
            emg_directions = cell(2, length(emg_labels));
            [emg_directions{1, :}] = deal('positive');
            [emg_directions{2, :}] = deal('negative');

            % save emg data
            save_folder = 'raw';
            save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'emgTrajectoriesRaw.mat');
            save ...
                ( ...
                [save_folder filesep save_file_name], ...
                'emg_raw_trajectories', ...
                'time_emg', ...
                'sampling_rate_emg', ...
                'emg_labels', ...
                'emg_directions' ...
                );
            addAvailableData('emg_raw_trajectories', 'time_emg', 'sampling_rate_emg', '_emg_labels', '_emg_directions', save_folder, save_file_name);
        end
    end
end

function importTrialDataForceplate(qtm_data, trial_info, file_info, study_settings, options)
    force_data_is_available = isfield(qtm_data, 'Force') & ~isempty(qtm_data.Force) & qtm_data.Force(1).NrOfSamples > 0;
    if force_data_is_available

        % determine start and end index
        first_frame_to_import = round(trial_info.start_frame * qtm_data.Force(1).SamplingFactor);
        last_frame_to_import = round(trial_info.end_frame * qtm_data.Force(1).SamplingFactor);

        % Force data - data are in qtm_data.Force(n).Force
        forceplate_table = study_settings.getTable('forceplate_table', true);
        number_of_forceplates = size(forceplate_table, 1);
        forceplate_raw_trajectories = [];
        forceplate_labels = {};
        forceplate_directions = {};
        for i_forceplate = 1 : number_of_forceplates
            this_plate_index = str2double(forceplate_table.index{i_forceplate});
            this_plate_label = forceplate_table.label{i_forceplate};
            
            % get forces and moments and combine to wrench
            this_plate_forces = qtm_data.Force(this_plate_index).Force(:, first_frame_to_import : last_frame_to_import)';
            this_plate_moments = qtm_data.Force(this_plate_index).Moment(:, first_frame_to_import : last_frame_to_import)';
            this_plate_wrench_local = [this_plate_forces this_plate_moments];
            
            % assemble transformation from forceplate to lab frame
            if strcmp(forceplate_table.translation{i_forceplate}, 'from_data')
                % mean of corner coordinates gives center
                this_plate_location = qtm_data.Force(this_plate_index).ForcePlateLocation * options.millimeter_to_meter;
                forceplate_to_world_translation = mean(this_plate_location)';
            else
                forceplate_to_world_translation = study_settings.get(forceplate_table.translation{i_forceplate})';
            end
            forceplate_to_world_rotation = reshape(study_settings.get(forceplate_table.rotation{i_forceplate}, true), 3, 3);
            
            this_plate_location = qtm_data.Force(this_plate_index).ForcePlateLocation * options.millimeter_to_meter;
            
            % this rotation matrix is for the normal lab frame and does something that looks useful for TD10, though not directly compared with pre data yet
            p_fp_from_lab = mean(this_plate_location)'; % p is the origin of the forceplate in lab coordinates
            R_fp_from_lab = reshape(study_settings.get(forceplate_table.rotation{i_forceplate}, true), 3, 3);
            
            
%             R_fp_from_lab = [1 0 0; 0 -1 0; 0 0 1]; % R is the orientation of the forceplate in lab coordinates, i.e 
            % the 1st column of R is the x-axis of the forceplate frame in world coordinates
            % the 2nd column of R is the y-axis of the forceplate frame in world coordinates
            % the 3rd column of R is the z-axis of the forceplate frame in world coordinates
            
            % this rotation matrix is for the inverse lab
%             p_fp_from_lab = mean(this_plate_location)'; % p is the origin of the forceplate in lab coordinates
%             R_fp_from_lab = [-1 0 0; 0 1 0; 0 0 1]; % R is the orientation of the forceplate in lab coordinates
            
            
            % build rigid transform
            g_fp_from_lab = [R_fp_from_lab p_fp_from_lab; 0 0 0 1];
            
            % invert rigid transform, because we want to transform the wrench from forceplate to lab coordinates
            g_lab_from_fp = inv(g_fp_from_lab);
            % test: p_lab_from_fp = -R_fp_from_lab * p_fp_from_lab
            
            % calculate adjoint
            A_lab_from_fp = rigidToAdjointTransformation(g_lab_from_fp);
            
            % transform wrench
            this_plate_wrench_world = (A_lab_from_fp' * this_plate_wrench_local')';
            
            
            A_fp_from_lab = rigidToAdjointTransformation([R_fp_from_lab p_fp_from_lab; 0 0 0 1]);
            A_t_inv = inv(A_fp_from_lab');
            this_plate_wrench_world = (A_t_inv * this_plate_wrench_local')';
            
            % invert wrench to change from ground reaction wrench to applied wrench
            this_wrench_world = -this_plate_wrench_world;
            
            tau_1 = (A_lab_from_fp' * this_plate_wrench_local')';
            tau_2 = (A_fp_from_lab' * this_plate_wrench_local')';
            
% figure; plot(this_plate_moments); set(gca, 'xlim', [0 10000])
% figure; plot(tau_1(:, 4:6)); set(gca, 'xlim', [0 10000])
% figure; plot(tau_2(:, 4:6)); set(gca, 'xlim', [0 10000])
% figure; plot(this_plate_wrench_world(:, 4:6)); set(gca, 'xlim', [0 10000])

%             world_to_forceplate_transform = [forceplate_to_world_rotation forceplate_to_world_translation; 0 0 0 1];
%             forceplate_to_world_transform = world_to_forceplate_transform^(-1);
%             
%             
%             forceplate_to_world_adjoint = rigidToAdjointTransformation(forceplate_to_world_transform);
%             
%             
%             this_plate_wrench_world = (forceplate_to_world_adjoint' * this_plate_wrench_local')';
            
            
% figure; plot(this_plate_forces)
% figure; plot(this_plate_moments)
% figure; plot(this_plate_wrench_world(:, 1:3))
% figure; plot(this_plate_wrench_world(:, 4:6))
            
%             forceplate_to_world_transformation = [forceplate_to_world_rotation forceplate_to_world_translation; 0 0 0 1];
            
            % transform to lab frame and store
%             forceplate_to_world_adjoint = rigidToAdjointTransformation(forceplate_to_world_transformation);
%             this_plate_wrench_world = (forceplate_to_world_adjoint' * this_plate_wrench_local')';
            forceplate_raw_trajectories = [forceplate_raw_trajectories this_wrench_world]; %#ok<AGROW>
            
            % create labels
            this_plate_labels = ...
              { ...
                ['fx_' this_plate_label], ...
                ['fy_' this_plate_label], ...
                ['fz_' this_plate_label], ...
                ['mx_' this_plate_label], ...
                ['my_' this_plate_label], ...
                ['mz_' this_plate_label], ...
              };
            forceplate_labels = [forceplate_labels this_plate_labels]; %#ok<AGROW>
            
            % create directions
            this_plate_directions = ...
              { ...
                study_settings.get('direction_x_pos', true), ...
                study_settings.get('direction_y_pos', true), ...
                study_settings.get('direction_z_pos', true), ....
                study_settings.get('direction_x_pos', true), ...
                study_settings.get('direction_y_pos', true), ...
                study_settings.get('direction_z_pos', true); ....
                study_settings.get('direction_x_neg', true), ...
                study_settings.get('direction_y_neg', true), ...
                study_settings.get('direction_z_neg', true), ....
                study_settings.get('direction_x_neg', true), ...
                study_settings.get('direction_y_neg', true), ...
                study_settings.get('direction_z_neg', true); ....
              };
            % NOTE: this defines directions and makes assumptions, make sure everything is right here
            forceplate_directions = [forceplate_directions this_plate_directions]; %#ok<AGROW>
            
        end

        sampling_rate_forceplate = qtm_data.Force(1).Frequency;
        time_forceplate = (1 : size(forceplate_raw_trajectories, 1))' / sampling_rate_forceplate;

        % save forceplate data
        save_folder = 'raw';
        data_source = 'qtm';
        save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'forceplateTrajectoriesRaw.mat');
        save ...
            ( ...
            [save_folder filesep save_file_name], ...
            'forceplate_raw_trajectories', ...
            'forceplate_labels', ...
            'time_forceplate', ...
            'sampling_rate_forceplate', ...
            'forceplate_directions', ...
            'data_source' ...
            );
        addAvailableData('forceplate_raw_trajectories', 'time_forceplate', 'sampling_rate_forceplate', '_forceplate_labels', '_forceplate_directions', save_folder, save_file_name);
    end
end

function importTrialDataMarker(qtm_data, trial_info, file_info, study_settings, subject_settings, options)
    marker_data_is_available = isfield(qtm_data, 'Trajectories') && ~isempty(qtm_data.Trajectories);
    if marker_data_is_available
        % figure out frames
        first_frame_to_import = round(trial_info.start_frame);
        last_frame_to_import = round(trial_info.end_frame);
        number_of_frames = last_frame_to_import - first_frame_to_import + 1;

        % get relevant data in QTM format (N x 3 x T), where N = number of markers, T = number of samples
        markers_temp = qtm_data.Trajectories.Labeled.Data(:, 1:3, first_frame_to_import:last_frame_to_import);
        marker_labels = qtm_data.Trajectories.Labeled.Labels;
        sampling_rate_mocap = qtm_data.FrameRate;
        time_mocap = (1 : number_of_frames)' / sampling_rate_mocap;

        % reformat to T x 3N
        marker_count = 1;
        marker_raw_trajectories = [];
        for i_marker = 1: size(markers_temp,1)
            this_marker = markers_temp(i_marker,:,:);
            marker_raw_trajectories(marker_count:marker_count+2,:) = reshape(this_marker, size(this_marker,2), size(this_marker,3)) * options.millimeter_to_meter; 
            marker_count = marker_count + 3;
        end
        marker_raw_trajectories = marker_raw_trajectories';


        % replace marker labels if necessary
        marker_label_replacement_map = subject_settings.get('marker_label_replacement_map', 1);
        for i_label = 1 : size(marker_label_replacement_map, 1)
            old_label = marker_label_replacement_map{i_label, 1};
            new_label = marker_label_replacement_map{i_label, 2};
            marker_labels{strcmp(marker_labels, old_label)} = new_label;
        end

        % triplicate labels
        marker_labels_loaded = marker_labels;
        number_of_markers = length(marker_labels_loaded);
        marker_labels = cell(3, number_of_markers);
        for i_marker = 1 : length(marker_labels)
            marker_labels{1, i_marker} = [marker_labels_loaded{i_marker} '_x'];
            marker_labels{2, i_marker} = [marker_labels_loaded{i_marker} '_y'];
            marker_labels{3, i_marker} = [marker_labels_loaded{i_marker} '_z'];
        end
        marker_labels = reshape(marker_labels, 1, number_of_markers*3);

        % make directions
        number_of_marker_trajectories = size(marker_raw_trajectories, 2);
        marker_directions = cell(2, number_of_marker_trajectories);
        [marker_directions{1, 1 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_x_pos', true));
        [marker_directions{2, 1 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_x_neg', true));
        [marker_directions{1, 2 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_y_pos', true));
        [marker_directions{2, 2 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_y_neg', true));
        [marker_directions{1, 3 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_z_pos', true));
        [marker_directions{2, 3 : 3 : number_of_marker_trajectories}] = deal(study_settings.get('direction_z_neg', true));

        % save
        save_folder = 'raw';
        save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'markerTrajectoriesRaw.mat');
        save ...
            ( ...
            [save_folder filesep save_file_name], ...
            'marker_raw_trajectories', ...
            'time_mocap', ...
            'sampling_rate_mocap', ...
            'marker_labels', ...
            'marker_directions' ...
            );
        addAvailableData('marker_raw_trajectories', 'time_mocap', 'sampling_rate_mocap', '_marker_labels', '_marker_directions', save_folder, save_file_name);
    end
end

function offset = analogOffset()
    offset = ...
      [ ...
        0; ...
        -0.0317098627837868; ...
        -0.0355064291396836; ...
        -0.0383662432835923; ...
        -0.0407330287129284; ...
        -0.0417785032417743; ...
        -0.0414159429847061; ...
        -0.0417277364763837; ...
        -0.0412429925743254; ...
        -0.0388849311198740; ...
        -0.0363677844014454; ...
        -0.0350654941860018; ...
        -0.0371848832588526; ...
        -0.0339162265276105; ...
        -0.0308550321637160; ...
        -0.0258480019743690; ...
        -0.0227666814457557; ...
        -0.0199298398628880; ...
        -0.0173543278850836; ...
        -0.0132742999011271; ...
        -0.0106610228969846; ...
        -0.00936478599793489; ...
        -0.00473625185189075; ...
        -0.00257883532928460; ...
        -0.000572734957710708; ...
        0.00132398762374120; ...
        0.00347722371700066; ...
        0.00398356837392289; ...
        0.00599911144133358; ...
        0.00753927394536458; ...
        0.00753085203582149; ...
        0.00870865857276826; ...
        0.00853249776011822; ...
        0.00853628316823052; ...
        0.00788663034824477; ...
        0.00840332559286772; ...
        0.00815475542401511; ...
        0.00798220864381083; ...
        0.00709983160489891; ...
        0.00690247828238899; ...
        0.00643181355926981; ...
        0.00503683000999455; ...
        0.00413383944497703; ...
        0.00329203775458176; ...
        0.00242120802380175; ...
        0.00149387016846525; ...
        0.000821574193582642; ...
        0.000369138339894271; ...
        -0.000277877672783866; ...
        -0.00102545670460508; ...
        -0.00271989182455190; ...
        -0.00365981488830602; ...
        -0.00482093843100540; ...
        -0.00494539216657319; ...
        -0.00588487154153494; ...
        -0.00599837804270820; ...
        -0.00682649900498600; ...
        -0.00655203723933173; ...
        -0.00791718834077937; ...
        -0.00825049603177419; ...
        -0.00769935445543801; ...
        -0.00852675928681101; ...
        -0.00815403884460952; ...
        -0.00963015799901790; ...
        -0.00895956615075910; ...
        -0.00961831343282515; ...
        -0.00966309582918967; ...
        -0.00952247347543045; ...
        -0.00919973803649565; ...
        -0.00920595233365562; ...
        -0.00893583474366810; ...
        -0.00877341543027255; ...
        -0.00870756374502735; ...
        -0.00856975753089673; ...
        -0.00870519970119821; ...
        -0.00932097017889166; ...
        -0.00848747970298325; ...
        -0.00844678720233416; ...
        -0.00783984295034923; ...
        -0.00773505034545563; ...
        -0.00705187100005489; ...
        -0.00704416271013297; ...
        -0.00689469491530370; ...
        -0.00674065592462925; ...
        -0.00612953452561960; ...
        -0.00560228535979301; ...
        -0.00535692483822525; ...
        -0.00488826650123864; ...
        -0.00468637134357453; ...
        -0.00436269192422967; ...
        -0.00396357745781306; ...
        -0.00378863032705390; ...
        -0.00367707688493169; ...
        -0.00314717004448473; ...
        -0.00288107214429201; ...
        -0.00249950966782508; ...
        -0.00246150124316424; ...
        -0.00185530510153731; ...
        -0.00161144218362400; ...
        -0.00146637549603207; ...
        -0.00102024355158730; ...
        -0.000815409068261150; ...
        -0.000734256181997323; ...
        -0.000832852161098741; ...
        -0.000792806693304171; ...
        -0.000108319700746151; ...
        -0.000265702930942080; ...
        -0.000279534687805283; ...
        -0.000491790882055976; ...
        -0.000426932735417163; ...
        -0.00117144863524299; ...
        -0.00153105624076844; ...
        -0.000998698616601734; ...
        -0.000935137108814876; ...
        -0.000958296975685613; ...
        -0.00142491381875454; ...
        -0.00164261683167122; ...
        -0.00264091356187746; ...
        -0.00309681499754499; ...
        -0.00401206048587333; ...
        -0.00396441579734863; ...
        -0.00422148403188150; ...
        -0.00529833879784958; ...
        -0.00596774150663659; ...
        -0.00678126028756942; ...
        -0.00723620698253669; ...
        -0.00772259027777311; ...
        -0.00825504622265649; ...
        -0.00816044205792954; ...
        -0.00916009217047842; ...
        -0.00977628691772603; ...
        -0.0106469097669994; ...
        -0.0109333378042864; ...
        -0.0119922291978138; ...
        -0.0122519306587239; ...
        -0.0130286490528753; ...
        -0.0130401366798907; ...
        -0.0137444705007748; ...
        -0.0138314855721378; ...
        -0.0141161149084041; ...
        -0.0144106983101242; ...
        -0.0146721926696580; ...
        -0.0144676458229069; ...
        -0.0148205448241381; ...
        -0.0148786138861228; ...
        -0.0144537309394677; ...
        -0.0143732644422432; ...
        -0.0139970179820059; ...
        -0.0137701494310054; ...
        -0.0128238368055325; ...
        -0.0125910885262401; ...
        -0.0135005954160290; ...
        -0.0126732101628155; ...
        -0.0115996832421770; ...
        -0.0105618871208364; ...
        -0.00950531667495813; ...
        -0.00839970631782627; ...
        -0.00740346782180268; ...
        -0.00593091658393519; ...
        -0.00513883242166635; ...
        -0.00375714780028513; ...
        -0.00162831240730377; ...
        -0.000394209661337186; ...
        0.00243617559528087; ...
        0.00190042906742605; ...
        0.00386235131119417; ...
        0.00538588999007050; ...
        0.00703525654969717; ...
        0.00907773138043932; ...
        0.0108388384692422; ...
        0.0129475880893617; ...
        0.0138018623944065; ...
        0.0152044950641930; ...
        0.0162984264486976; ...
        0.0179685779542922; ...
        0.0188687694610845; ...
        0.0202168224764048; ...
        0.0208049101290397; ...
        0.0220546340257348; ...
        0.0223920981075532; ...
        0.0225321870361555; ...
        0.0229908094999018; ...
        0.0241814339901651; ...
        0.0240792613920782; ...
        0.0238237301350370; ...
        0.0233348590569662; ...
        0.0232842471463997; ...
        0.0227356714357168; ...
        0.0216668784253855; ...
        0.0215045626865980; ...
        0.0215450198313842; ...
        0.0203315176705363; ...
        0.0190577137879586; ...
        0.0179738315997273; ...
        0.0168931232604397; ...
        0.0156401403073261; ...
        0.0150204841270369; ...
        0.0147189566948640; ...
        0.0131844504728420; ...
        0.0123703604766217; ...
        0; ...
      ];
end


















  
