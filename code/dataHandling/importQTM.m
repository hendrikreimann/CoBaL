%     This file is part of the CoBaL code base
%     Copyright (C) 2017 Hendrik Reimann <hendrikreimann@gmail.com>
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.

% this script transform raw data from ascii into matlab format

% input:
% Experimental data files generated by e.g. Nexus, QTM, labview etc.
% Files are expected to be in subfolders named <subject code>_<source type>, e.g. XYZ_labview
% any source type is viable, but if it is not in the default list, it must be specified as a name-value pair,
% e.g. importAscii('sources', 'someSource') would look for data in the subfolder XYZ_someSource
%
% output:
% Files containing the same data in .mat format, with some additional information about where they came from.
% Output files will be saved to folders "raw" and "processed".

function importQTM(varargin)
    % parse arguments
    parser = inputParser;
    parser.KeepUnmatched = true;
    addParameter(parser, 'visualize', false)
%     addParameter(parser, 'SyncronizationMode', 'events') % options are 'events', 'table', 'encoded'
    parse(parser, varargin{:})
    options.visualize = parser.Results.visualize;


    %% prepare
    % set some parameters
    options.millimeter_to_meter = 1e-3;

    study_settings = loadSettingsFromFile('study');
    subject_settings = loadSettingsFromFile('subject');
    options.import_mode = study_settings.get('qtm_import_mode', 1);
    % qtm_import_mode determines how the data in the QTM files are cut into pieces and mapped onto trials accoding to
    % the labview protocol file | ATTENTION: mode 3. events is currently the only one that works, the other ones will
    % have to be updated to generate a trial table from the available information
    % 1. encoded -- analog signal, increasing edge signals switch to a new step in protocol file -- currently not working
    % 2. table -- analog signal, increasing edge signals switch to new trial in table in subject settings -- currently not working 
    % 3. events -- QTM events signal start/stop of trials, info is stored as event label
    % 4. bijective -- each QTM file is mapped to a labview trial with trial type and number from the QTM file name -- currently not working 

    options.sync_mode = options.import_mode; % placeholder for now, I shouldn't need this anymore
    
%     analog_to_protocol_mapping = subject_settings.get('analog_to_protocol_mapping', 1);

    % create folders if necessary
    if ~directoryExists('raw')
        mkdir('raw')
    end
    if ~directoryExists('processed')
        mkdir('processed')
    end
    if ~directoryExists('analysis')
        mkdir('analysis')
    end
    options.qtm_source_dir = 'qtm';

    %% import data
    data_dir_mat = dir([options.qtm_source_dir filesep '*mat']);
    [file_name_list{1:length(data_dir_mat)}] = deal(data_dir_mat.name);

    % go through QTM files and import
    number_of_files = length(file_name_list);
    for i_file = 1 : number_of_files
        
        data_file_name = file_name_list{i_file};
        importSingleQtmFile(data_file_name, options, study_settings, subject_settings);
    end

end


function importSingleQtmFile(data_file_name, options, study_settings, subject_settings)

    disp(['Importing ' options.qtm_source_dir filesep data_file_name])

    % file info
    file_info = struct;
    [file_info.collection_date, file_info.subject_id, file_info.trial_type, file_info.trial_number] ...
        = getFileParameters(data_file_name);

    % load QTM data from file
    var_name = whos('-file', [options.qtm_source_dir, filesep, data_file_name]);
    temp_data = load([options.qtm_source_dir, filesep, data_file_name]);
    qtm_data = temp_data.(var_name.name);

    % determine trial table
    trial_table = determineTrialTable(qtm_data, file_info, options);
    
    % import data according to trial table
    for i_trial = 1 : size(trial_table, 1)
        % get info from table
        trial_info.start_time = trial_table{i_trial, 'start_time'};
        trial_info.end_time = trial_table{i_trial, 'end_time'};
        trial_info.start_frame = trial_table{i_trial, 'start_frame'};
        trial_info.end_frame = trial_table{i_trial, 'end_frame'};
        trial_info.trial_type = trial_table{i_trial, 'trial_type'};
        trial_info.trial_number = trial_table{i_trial, 'trial_number'};
        
        % import data
        importTrialDataAnalog(qtm_data, trial_info, file_info, study_settings, subject_settings);
        importTrialDataForceplate(qtm_data, trial_info, file_info, study_settings, options);
        importTrialDataMarker(qtm_data, trial_info, file_info, subject_settings, options);
        
        % report to command window
        this_trial_length = trial_info.end_time - trial_info.start_time;
        disp( ...
          [ ...
            '  Saved data files for type ' char(trial_info.trial_type) ...
            ', trial ' num2str(trial_info.trial_number) ...
            ' with duration ' num2str(this_trial_length) ...
            's (' num2str(trial_info.start_time) ...
            '-' num2str(trial_info.end_time) ...
            ')' ...
          ] ...
        )
    end
    
    
    % after here is old stuff -- leave this code around, in case we want to re-import old data at some point. This code
    % contains info about how we used to import data based on the analog encoding or table in the subject settings
if false

    % determine start and end indices
    if ~analog_data_available
        start_indices_mocap = 1;
        end_indices_mocap = qtm_data.Frames;
        number_of_trials_in_this_qtm_file = length(start_indices_mocap);
    else
        file_info.analog_fs = qtm_data.Analog.Frequency;

        if strcmp(options.import_mode, 'events')
            % break up into chunks for trials
            trigger_mask = contains(qtm_data.Analog.Labels, 'labview_sync');
            trigger = qtm_data.Analog.Data(trigger_mask,:);
            % normalise to the range [0,1] and round
            trigger = round(trigger/max(trigger));

            % find edges
            trigger_edges = [diff(trigger), 0];
            analog_indices = 1:length(qtm_data.Analog.Data);
            start_indices_analog = analog_indices(trigger_edges == -1); % trials start on negative edge
            end_indices_analog = analog_indices(trigger_edges == 1); % trials end on positive edge
            analog_time = (1 : qtm_data.Analog.NrOfSamples)' / qtm_data.Analog.Frequency;


            % figure out protocol steps
            protocol_step_mask = contains(qtm_data.Analog.Labels, 'currentStep');
            protocol_step_analog = qtm_data.Analog.Data(protocol_step_mask,:);
            protocol_step_up_indices = find([diff(protocol_step_analog), 0] > 0.08);

            if isempty(start_indices_analog) && isempty(end_indices_analog)
                start_indices_analog = 1;
                end_indices_analog = length(analog_indices);
            end

            % check whether each start index has a matching end index
            for i_start_index = 1 : length(start_indices_analog)
                % remove end indices that come before the start index - HR: not tested yet
                while length(end_indices_analog) >= i_start_index && end_indices_analog(i_start_index) <= start_indices_analog(i_start_index)
                    end_indices_analog(i_start_index) = [];
                end
            end
            if length(end_indices_analog) > length(start_indices_analog)
                disp('More end indices than start indices, removing superfluous ones')
                end_indices_analog(length(start_indices_analog)+1 : end) = [];
            end
            if length(start_indices_analog) > length(end_indices_analog)
                disp('More start indices than end indices, removing superfluous ones')
                start_indices_analog(length(end_indices_analog)+1 : end) = [];
            end

            % provide visual feedback if desired
            if options.visualize
                figure; hold on;
                time_analog = (1 : length(protocol_step_analog)) * 1/analog_fs;
                plot(time_analog, protocol_step_analog);
                plot(time_analog(protocol_step_up_indices), protocol_step_analog(protocol_step_up_indices), '^');
                plot(time_analog(start_indices_analog), protocol_step_analog(start_indices_analog), '>');
                plot(time_analog(end_indices_analog), protocol_step_analog(end_indices_analog), '<');
                drawnow
            end

            if end_indices_analog(end) > length(qtm_data.Analog.Data)
                end_indices_analog(end) = length(qtm_data.Analog.Data);
            end                    
        end
        if strcmp(options.import_mode, 'bijective')

            start_indices_analog = 1;
            end_indices_analog = qtm_data.Analog.NrOfSamples;
            analog_time = (1 : qtm_data.Analog.NrOfSamples) * 1/analog_fs;
        end                


        number_of_trials_in_this_qtm_file = length(start_indices_analog);
    end

    % go through events and cut out the data
    delays_to_closest_event = [];
    for i_trial_this_qtm_file = 1 : number_of_trials_in_this_qtm_file
        if ~analog_data_available
            % we don't have analog data, so we simply import the whole QTM trial
            importing_trial_number = trial_number;
            importing_trial_type = trial_type;
            save_this_trial = 1;
            this_trial_length = qtm_data.Frames / qtm_data.FrameRate;
            this_trial_length_expected = this_trial_length;

        else
            % we do have analog data, so we use event markers
            this_trial_start_index = start_indices_analog(i_trial_this_qtm_file);
            this_trial_end_index = end_indices_analog(i_trial_this_qtm_file);
            number_of_samples = this_trial_end_index - this_trial_start_index + 1;
            this_trial_length = number_of_samples / file_info.analog_fs;

            % align analog indices with mocap indices
            sampling_rate_mocap = qtm_data.FrameRate;
            start_indices_mocap = round(start_indices_analog * sampling_rate_mocap/file_info.analog_fs);
            if start_indices_mocap == 0
                start_indices_mocap = 1;
            end
            end_indices_mocap = round(end_indices_analog * sampling_rate_mocap/file_info.analog_fs);

        end

        if strcmp(options.sync_mode, 'encoded')
            % TODO: this is a legacy mode that's not in use anymore. When separating the labview data import from
            % this function, I did not make sure that this keeps working. To make it work again, you will probably
            % load information from protocolInfo.mat and maybe others.
%             if ~protocol_file_available
%                 error('Failed to locate protocol.csv in the labview folder, exiting.')
%             end
%             % figure out protocol step from the analog signal
%             this_trial_protocol_step_analog = protocol_step_analog(this_trial_start_index:this_trial_end_index);
% 
%             analog_to_step_range = (-10 : 0.1 : 10)';
%             offset = analogOffset();
%             this_trial_offset = interp1(analog_to_step_range, offset, this_trial_protocol_step_analog);
%             this_trial_protocol_step_analog_corrected = this_trial_protocol_step_analog + this_trial_offset;
% 
%             % discrete map from [-10 10] --> [0 200]
%             this_trial_protocol_step_digital = round((this_trial_protocol_step_analog_corrected + 10) * 10);
%             this_trial_protocol_step = median(this_trial_protocol_step_digital);
% 
%             if sum(this_trial_protocol_step_digital(2:end-1)~=median(this_trial_protocol_step_digital)) > 20
%                 warning(['Ambiguous protocol step data for trial starting at time step ' num2str(this_trial_start_index)]);
%             end
%             this_trial_protocol_index = median(this_trial_protocol_step) + 1;
%             importing_trial_type = protocol_trial_type{this_trial_protocol_index};
%             importing_trial_number = protocol_trial_number(this_trial_protocol_index);
%             this_trial_length_expected = protocol_trial_duration(this_trial_protocol_index);           
%             save_this_trial = protocol_trial_saved(this_trial_protocol_index);
        end
        if strcmp(options.sync_mode, 'table')
            % TODO: this is a legacy mode that's not in use anymore. When separating the labview data import from
            % this function, I did not make sure that this keeps working. To make it work again, you will probably
            % load information from protocolInfo.mat and maybe others.
%             if ~protocol_file_available
%                 error('Failed to locate protocol.csv in the labview folder, exiting.')
%             end
%             trial_type_matches = strcmp(analog_to_protocol_mapping(:, 1), trial_type);
%             trial_number_matches = strcmp(analog_to_protocol_mapping(:, 2), num2str(trial_number));
%             index_number_matches = strcmp(analog_to_protocol_mapping(:, 3), num2str(i_trial_this_qtm_file));
%             this_trial_protocol_index = str2double(analog_to_protocol_mapping{trial_type_matches & trial_number_matches & index_number_matches, 4});
%             importing_trial_type = protocol_trial_type{this_trial_protocol_index};
%             importing_trial_number = protocol_trial_number(this_trial_protocol_index);
%             this_trial_length_expected = protocol_trial_duration(this_trial_protocol_index);           
%             save_this_trial = protocol_trial_saved(this_trial_protocol_index);
        end
        if strcmp(options.sync_mode, 'events')
            % I don't think I need this part at all, let's remove it for now
%             if ~analog_data_available
%                 this_trial_start_time = 0;
%                 this_trial_end_time = this_trial_length;
%             else
%                 this_trial_start_time = analog_time(this_trial_start_index);
%                 this_trial_end_time = analog_time(this_trial_end_index);
%             end
% 
%             if ~event_data_available
%                 start_event_times = this_trial_start_time;
%                 end_event_times = this_trial_end_time;
%                 start_event_types = {file_info.trial_type};
%                 end_event_types = {file_info.trial_type};
%                 start_event_numbers = {num2str(file_info.trial_number)};
%                 end_event_numbers = {num2str(file_info.trial_number)};
%             end
% 
%             [delay_to_closest_start_event, closest_start_event_index] = min(abs(start_event_times - this_trial_start_time));
%             [delay_to_closest_end_event, closest_end_event_index] = min(abs(end_event_times - this_trial_end_time));
%             closest_start_event_time = start_event_times(closest_start_event_index);
%             closest_end_event_time = end_event_times(closest_end_event_index);
%             type_from_start = start_event_types{closest_start_event_index};
%             type_from_end = end_event_types{closest_end_event_index};
%             number_from_start = str2double(start_event_numbers{closest_start_event_index});
%             number_from_end = str2double(end_event_numbers{closest_end_event_index});
% 
%             this_trial_length_expected = closest_end_event_time - closest_start_event_time;
%             if ~strcmp(type_from_start, type_from_end)
%                 Error('Trial type from start and end events do not match');
%             end                        
%             if ~(number_from_start == number_from_end)
%                 Error('Trial number from start and end events do not match');
%             end                        
%             importing_trial_type = type_from_start;
%             importing_trial_number = number_from_start;
%             save_this_trial = 1;
% 
%             delays_to_closest_event = [delays_to_closest_event; [delay_to_closest_start_event, delay_to_closest_end_event]];
        end
        if strcmp(options.import_mode, 'bijective')
%             this_trial_start_time = analog_time(this_trial_start_index);
%             this_trial_end_time = analog_time(this_trial_end_index);
% 
% 
%             this_trial_duration = this_trial_end_time - this_trial_start_time;
% 
%             importing_trial_type = trial_type;
%             importing_trial_number = trial_number;
%             save_this_trial = 1;

        end

        % sanity check: recorded data should be within 1% of expected duration
        if this_trial_length < this_trial_length_expected*0.99 || this_trial_length > this_trial_length_expected*1.01
            warning ...
              ( ...
                [ ...
                  'Problem with trial starting at time step ' ...
                  num2str(this_trial_start_index) ...
                  ', expected duration is ' ...
                  num2str(this_trial_length_expected) ...
                  's, but data is ' ...
                  num2str(this_trial_length) ...
                  's long.' ...
                ] ...
              );
        end

        if analog_data_available
            
            % import analog data (non-emg)
            analog_data_to_import = study_settings.get('analog_data_to_import', 1);
            number_of_analog_channels_to_import = length(analog_data_to_import);
            if number_of_analog_channels_to_import > 0
                sampling_rate_analog = file_info.analog_fs;
                time_analog = (1 : number_of_samples)' / sampling_rate_analog;
                analog_labels = analog_data_to_import;
                analog_trajectories = zeros(number_of_samples, number_of_analog_channels_to_import);
                data_type = 'analog';
                for i_channel = 1 : number_of_analog_channels_to_import
                    index_in_loaded_data = strcmp(qtm_data.Analog.Labels, analog_data_to_import(i_channel));

                    analog_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, this_trial_start_index:this_trial_end_index)';

                end

                % make directions
                analog_directions = cell(2, length(analog_labels));
                [analog_directions{1, :}] = deal('positive');
                [analog_directions{2, :}] = deal('negative');

                % save analog data
                if save_this_trial
                    save_folder = 'processed';
                    save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, importing_trial_type, importing_trial_number, 'analogTrajectories.mat');
                    save ...
                        ( ...
                        [save_folder filesep save_file_name], ...
                        'analog_trajectories', ...
                        'time_analog', ...
                        'sampling_rate_analog', ...
                        'data_source', ...
                        'analog_labels', ...
                        'analog_directions' ...
                        );
                    addAvailableData('analog_trajectories', 'time_analog', 'sampling_rate_analog', '_analog_labels', '_analog_directions', save_folder, save_file_name);
                end                    
            end

            % import emg data
            emg_import_map_header = subject_settings.get('emg_import_map_header', 1);
            emg_import_map = subject_settings.get('emg_import_map', 1);

            import_emg_data = 1;
            if isempty(emg_import_map)
                import_emg_data = 0;
            else
                emg_data_to_import = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_qtm_file'));
                number_of_emg_channels_to_import = length(emg_data_to_import);
                if number_of_emg_channels_to_import == 0
                    import_emg_data = 0;
                end
            end


            if import_emg_data
                % EMG
                sampling_rate_emg = file_info.analog_fs;
                time_emg = (1 : number_of_samples)' / sampling_rate_emg;
                emg_labels = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_cobal'))';
                emg_raw_trajectories = zeros(number_of_samples, number_of_emg_channels_to_import);
                data_type = 'emg';
                for i_channel = 1 : number_of_emg_channels_to_import
                    index_in_loaded_data = strcmp(qtm_data.Analog.Labels, emg_data_to_import(i_channel));

                    emg_raw_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, this_trial_start_index:this_trial_end_index)';

                end

                % make directions
                emg_directions = cell(2, length(emg_labels));
                [emg_directions{1, :}] = deal('positive');
                [emg_directions{2, :}] = deal('negative');

                % save emg data
                if save_this_trial
                    save_folder = 'raw';
                    save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, importing_trial_type, importing_trial_number, 'emgTrajectoriesRaw.mat');
                    save ...
                        ( ...
                        [save_folder filesep save_file_name], ...
                        'emg_raw_trajectories', ...
                        'time_emg', ...
                        'sampling_rate_emg', ...
                        'data_source', ...
                        'emg_labels', ...
                        'emg_directions' ...
                        );
                    addAvailableData('emg_raw_trajectories', 'time_emg', 'sampling_rate_emg', '_emg_labels', '_emg_directions', save_folder, save_file_name);
                end                    
            end
        end


        if force_data_available
            % Force data - data are in qtm_data.Force(n).Force
            force_plates_to_import = study_settings.get('force_plates_to_import', 1);
            data_type = 'forceplate';
            if any(any(qtm_data.Force(force_plates_to_import(1)).Force))
                forceplate_tajectories_Left = ...
                    [ ...
                    qtm_data.Force(force_plates_to_import(1)).Force(:, this_trial_start_index : this_trial_end_index)', ...
                    qtm_data.Force(force_plates_to_import(1)).Moment(:, this_trial_start_index : this_trial_end_index)' ...
                    ];
                forceplate_tajectories_Right = ...
                    [ ...
                    qtm_data.Force(force_plates_to_import(2)).Force(:, this_trial_start_index : this_trial_end_index)', ...
                    qtm_data.Force(force_plates_to_import(2)).Moment(:, this_trial_start_index : this_trial_end_index)' ...
                    ];
                forceplate_raw_trajectories = [forceplate_tajectories_Left, forceplate_tajectories_Right];
            else % currently taking volts... need to scale accordinginly
                warning('No force data found, using analog data instead. This is currently not scaling correctly.')
                forceplate_raw_trajectories = [qtm_data.Analog.Data(1:12, this_trial_start_index : this_trial_end_index)]';
            end

            % check if the last data point is NaN for some reason and remove if necessary
            if any(isnan(forceplate_raw_trajectories(end, :))) & ~any(isnan(forceplate_raw_trajectories(end-1, :)))
                forceplate_raw_trajectories = forceplate_raw_trajectories(1:end-1, :);
            end


            forceplate_labels = qtm_data.Analog.Labels(1:12);
            %
            forceplate_location_left = mean(qtm_data.Force(1).ForcePlateLocation) * options.millimeter_to_meter; % mean of corner coordinates gives center
            forceplate_location_right = mean(qtm_data.Force(2).ForcePlateLocation) * options.millimeter_to_meter; % mean of corner coordinates gives center

            sampling_rate_forceplate = file_info.analog_fs;
            time_forceplate = (1 : size(forceplate_raw_trajectories, 1))' / sampling_rate_forceplate;

            % make directions
            % NOTE: this defines directions and makes assumptions, make sure everything is right here
            forceplate_directions = cell(2, length(forceplate_labels));
            [forceplate_directions{1, [1 4 7 10]}] = deal('right');
            [forceplate_directions{2, [1 4 7 10]}] = deal('left');
            [forceplate_directions{1, [2 5 8 11]}] = deal('forward');
            [forceplate_directions{2, [2 5 8 11]}] = deal('backward');
            [forceplate_directions{1, [3 6 9 12]}] = deal('up');
            [forceplate_directions{2, [3 6 9 12]}] = deal('down');

            % save forceplate data
            if save_this_trial
                save_folder = 'raw';
                save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, importing_trial_type, importing_trial_number, 'forceplateTrajectoriesRaw.mat');
                save ...
                    ( ...
                    [save_folder filesep save_file_name], ...
                    'forceplate_raw_trajectories', ...
                    'forceplate_labels', ...
                    'data_source', ...
                    'time_forceplate', ...
                    'sampling_rate_forceplate', ...
                    'forceplate_location_left', ...
                    'forceplate_location_right', ...
                    'forceplate_directions' ...
                    );
                addAvailableData('forceplate_raw_trajectories', 'time_forceplate', 'sampling_rate_forceplate', '_forceplate_labels', '_forceplate_directions', save_folder, save_file_name);
            end
        end

        % Markers
        this_trial_start_index_mocap = start_indices_mocap(i_trial_this_qtm_file);
        this_trial_end_index_mocap = end_indices_mocap(i_trial_this_qtm_file);
        number_of_frames = this_trial_end_index_mocap - this_trial_start_index_mocap + 1;

        temp_markers = qtm_data.Trajectories.Labeled.Data(:, 1:3, this_trial_start_index_mocap:this_trial_end_index_mocap);

        data_type = 'markers';
        % deal with marker data

        marker_labels = qtm_data.Trajectories.Labeled.Labels;
        sampling_rate_mocap = qtm_data.FrameRate;
        time_mocap = (1 : number_of_frames)' / sampling_rate_mocap;

        marker_count = 1;
        marker_raw_trajectories = [];
        for i_marker = 1: size(temp_markers,1)
            this_marker = temp_markers(i_marker,:,:);
            marker_raw_trajectories(marker_count:marker_count+2,:) = reshape(this_marker, size(this_marker,2), size(this_marker,3)) * options.millimeter_to_meter; 
            marker_count = marker_count + 3;
        end
        marker_raw_trajectories = marker_raw_trajectories';


        % replace marker labels if necessary
        marker_label_replacement_map = subject_settings.get('marker_label_replacement_map', 1);
        for i_label = 1 : size(marker_label_replacement_map, 1)
            old_label = marker_label_replacement_map{i_label, 1};
            new_label = marker_label_replacement_map{i_label, 2};
            marker_labels{strcmp(marker_labels, old_label)} = new_label;
        end

        % triplicate labels
        marker_labels_loaded = marker_labels;
        number_of_markers = length(marker_labels_loaded);
        marker_labels = cell(3, number_of_markers);
        for i_marker = 1 : length(marker_labels)
            marker_labels{1, i_marker} = [marker_labels_loaded{i_marker} '_x'];
            marker_labels{2, i_marker} = [marker_labels_loaded{i_marker} '_y'];
            marker_labels{3, i_marker} = [marker_labels_loaded{i_marker} '_z'];
        end
        marker_labels = reshape(marker_labels, 1, number_of_markers*3);

        % make directions
        % NOTE: this defines directions and makes assumptions, make sure everything is right here
        number_of_marker_trajectories = size(marker_raw_trajectories, 2);
        marker_directions = cell(2, number_of_marker_trajectories);
        [marker_directions{1, 1 : 3 : number_of_marker_trajectories}] = deal('right');
        [marker_directions{2, 1 : 3 : number_of_marker_trajectories}] = deal('left');
        [marker_directions{1, 2 : 3 : number_of_marker_trajectories}] = deal('forward');
        [marker_directions{2, 2 : 3 : number_of_marker_trajectories}] = deal('backward');
        [marker_directions{1, 3 : 3 : number_of_marker_trajectories}] = deal('up');
        [marker_directions{2, 3 : 3 : number_of_marker_trajectories}] = deal('down');


        % save
        if save_this_trial
            save_folder = 'raw';
            save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, importing_trial_type, importing_trial_number, 'markerTrajectoriesRaw.mat');
            save ...
                ( ...
                [save_folder filesep save_file_name], ...
                'marker_raw_trajectories', ...
                'time_mocap', ...
                'data_source', ...
                'sampling_rate_mocap', ...
                'marker_labels', ...
                'marker_directions' ...
                );
            addAvailableData('marker_raw_trajectories', 'time_mocap', 'sampling_rate_mocap', '_marker_labels', '_marker_directions', save_folder, save_file_name);
        end

        if save_this_trial
%                 disp(['  Saved data files for type ' importing_trial_type ', trial ' num2str(importing_trial_number) ' with duration ' num2str(this_trial_duration) 's'])
            disp( ...
                  [ ...
                    '  Saved data files for type ' importing_trial_type ...
                    ', trial ' num2str(importing_trial_number) ...
                    ' with duration ' num2str(this_trial_length) ...
                    's (' num2str(this_trial_start_index_mocap * 1/sampling_rate_mocap) ...
                    '-' num2str(this_trial_end_index_mocap * 1/sampling_rate_mocap) ...
                    ')' ...
                  ] ...
                )
        end
    end

end

end

function trial_table = determineTrialTable(qtm_data, file_info, options)
    % initialize flags
    import_whole_trial = false;
    
    % prepare trial table
    trial_table_variable_names = {'start_time', 'end_time', 'start_frame', 'end_frame', 'trial_type', 'trial_number'};
    trial_table_variable_types = {'double', 'double', 'double', 'double', 'string', 'string'};
    trial_table = table ...
      ( ...
        'Size', [0, 6], ...
        'VariableNames', trial_table_variable_names, ...
        'VariableTypes', trial_table_variable_types ...
      );
    
    if strcmp(options.import_mode, 'events')
        % process events in this data file
        events = qtm_data.Events;
        event_times = [events(:).Time]';
        event_frames = [events(:).Frame]';
        event_labels = {events(:).Label}';
        event_labels_type = cell(size(events));
        event_labels_number = cell(size(events));
        event_labels_suffix = cell(size(events));
        for i_event = 1 : length(events)
            this_event_label = event_labels{i_event};
            this_event_label_split = strsplit(this_event_label, '_');
            event_labels_type{i_event} = this_event_label_split{1};
            event_labels_number{i_event} = this_event_label_split{2};
            event_labels_suffix{i_event} = this_event_label_split{3};
        end
        disp(['  found ' num2str(length(events)) ' events']);
        if (isempty(events))
            if (strcmp(file_info.trial_type, 'static')) || (strcmp(file_info.trial_type, 'calibration'))
                disp(['  trial type: ' file_info.trial_type ' - importing whole trial'])
                import_whole_trial = true;
            else
                disp(' no data will be imported')
            end
        end
        
        % collect event info in table
        event_table_variable_names = {'time', 'frame', 'type', 'number', 'suffix'};
        event_table_variable_types = {'double', 'double', 'string', 'string', 'string'};
        event_table = table ...
          ( ...
            'Size', [length(events), 5], ...
            'VariableNames', event_table_variable_names, ...
            'VariableTypes', event_table_variable_types ...
          );
        event_table.time = event_times;
        event_table.frame = event_frames;
        for i_event = 1 : length(events)
            this_event_label = event_labels{i_event};
            this_event_label_split = strsplit(this_event_label, '_');
            event_table(i_event, 'type') = this_event_label_split(1);
            event_table(i_event, 'number') = this_event_label_split(2);
            event_table(i_event, 'suffix') = this_event_label_split(3);
        end
        
        % re-structure events to combine start and end
        discarded_events = table;
        while size(event_table, 1) > 0
            if size(event_table, 1) == 1
                % if there is only a single event left, discard it
                discarded_events = [discarded_events; event_table(1, :)]; %#ok<AGROW>
                event_table(1, :) = [];
            else
                % check if first two events are a fit
                if strcmp(event_table{1, 'suffix'}, 'start') && strcmp(event_table{2, 'suffix'}, 'end') ...
                        && strcmp(event_table{1, 'number'}, event_table{2, 'number'}) ...
                        && strcmp(event_table{1, 'type'}, event_table{2, 'type'})
                    % we have a fit, import the first two events
                    this_event_start_time = event_table{1, 'time'};
                    this_event_end_time = event_table{2, 'time'};
                    this_event_start_frame = event_table{1, 'frame'};
                    this_event_end_frame = event_table{2, 'frame'};
                    this_event_trial_type = event_table{1, 'type'};
                    this_event_trial_number = event_table{1, 'number'};
                    this_trial_data = ...
                      { ...
                        this_event_start_time, ...
                        this_event_end_time, ...
                        this_event_start_frame, ...
                        this_event_end_frame, ...
                        this_event_trial_type, ...
                        this_event_trial_number ...
                      };
                    trial_table = [trial_table; this_trial_data]; %#ok<AGROW>
                    
                    % remove imported events from event table
                    event_table([1 2], :) = [];
                else
                    % no fit, discard first event in the table
                    discarded_events = [discarded_events; event_table(1, :)]; %#ok<AGROW>
                    event_table(1, :) = [];
                end
                
            end
            
            
            
        end
        if size(discarded_events, 1) > 0
            disp('Warning: Could not fully resolve events. Discarded events:')
            disp(discarded_events);
        end
    end
    
    if import_whole_trial
        
        trial_start_time = qtm_data.StartFrame / qtm_data.FrameRate;
        trial_end_time = (qtm_data.Frames - qtm_data.StartFrame + 1) / qtm_data.FrameRate;
        this_trial_data = ...
          { ...
            trial_start_time, ...
            trial_end_time, ...
            qtm_data.StartFrame, ...
            qtm_data.Frames, ...
            file_info.trial_type, ...
            file_info.trial_number...
          };
        trial_table = [trial_table; this_trial_data];
        
    end
end

function importTrialDataAnalog(qtm_data, trial_info, file_info, study_settings, subject_settings)
    analog_data_is_available = isfield(qtm_data, 'Analog');
    if analog_data_is_available
        % find columns to import
        analog_data_to_import = study_settings.get('analog_data_to_import', 1);
        number_of_analog_channels_to_import = length(analog_data_to_import);
        
        % import analog data (non-emg)
        if number_of_analog_channels_to_import > 0
            % find index of first and last frame to import
            first_frame_to_import = round(trial_info.start_frame * qtm_data.Analog.SamplingFactor);
            last_frame_to_import = round(trial_info.end_frame * qtm_data.Analog.SamplingFactor);
            
            % make time array for this trial
            sampling_rate_analog = qtm_data.Analog.Frequency;
            number_of_samples = last_frame_to_import - first_frame_to_import + 1;
            time_analog = (1 : number_of_samples) / sampling_rate_analog;
            
            % extract data
            analog_trajectories = zeros(number_of_samples, number_of_analog_channels_to_import);
            for i_channel = 1 : number_of_analog_channels_to_import
                index_in_loaded_data = strcmp(qtm_data.Analog.Labels, analog_data_to_import(i_channel));
                analog_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, first_frame_to_import:last_frame_to_import)';
            end

            % make directions
            analog_directions = cell(2, length(analog_data_to_import));
            [analog_directions{1, :}] = deal('positive');
            [analog_directions{2, :}] = deal('negative');

            % save analog data
            analog_labels = analog_data_to_import;
            save_folder = 'processed';
            save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'analogTrajectories.mat');
            save ...
                ( ...
                [save_folder filesep save_file_name], ...
                'analog_trajectories', ...
                'time_analog', ...
                'sampling_rate_analog', ...
                'analog_labels', ...
                'analog_directions' ...
                );
            addAvailableData('analog_trajectories', 'time_analog', 'sampling_rate_analog', '_analog_labels', '_analog_directions', save_folder, save_file_name);
        end

        % import emg data
        emg_import_map_header = subject_settings.get('emg_import_map_header', 1);
        emg_import_map = subject_settings.get('emg_import_map', 1);

        import_emg_data = 1;
        if isempty(emg_import_map)
            import_emg_data = 0;
        else
            emg_data_to_import = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_qtm_file'));
            number_of_emg_channels_to_import = length(emg_data_to_import);
            if number_of_emg_channels_to_import == 0
                import_emg_data = 0;
            end
        end

        if import_emg_data
            % find index of first and last frame to import
            first_frame_to_import = round(trial_info.start_frame * qtm_data.Analog.SamplingFactor);
            last_frame_to_import = round(trial_info.end_frame * qtm_data.Analog.SamplingFactor);
            
            % make time array for this trial
            sampling_rate_emg = qtm_data.Analog.Frequency;
            number_of_samples = last_frame_to_import - first_frame_to_import + 1;
            time_emg = (1 : number_of_samples) / sampling_rate_emg;
            
            % EMG
            emg_labels = emg_import_map(:, strcmp(emg_import_map_header, 'label_in_cobal'))';
            emg_raw_trajectories = zeros(number_of_samples, number_of_emg_channels_to_import);
            for i_channel = 1 : number_of_emg_channels_to_import
                index_in_loaded_data = strcmp(qtm_data.Analog.Labels, emg_data_to_import(i_channel));
                emg_raw_trajectories(:, i_channel) = qtm_data.Analog.Data(index_in_loaded_data, first_frame_to_import:last_frame_to_import)';
            end

            % make directions
            emg_directions = cell(2, length(emg_labels));
            [emg_directions{1, :}] = deal('positive');
            [emg_directions{2, :}] = deal('negative');

            % save emg data
            save_folder = 'raw';
            save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'emgTrajectoriesRaw.mat');
            save ...
                ( ...
                [save_folder filesep save_file_name], ...
                'emg_raw_trajectories', ...
                'time_emg', ...
                'sampling_rate_emg', ...
                'emg_labels', ...
                'emg_directions' ...
                );
            addAvailableData('emg_raw_trajectories', 'time_emg', 'sampling_rate_emg', '_emg_labels', '_emg_directions', save_folder, save_file_name);
        end
    end
end

function importTrialDataForceplate(qtm_data, trial_info, file_info, study_settings, options)
    % determine start and end index
    first_frame_to_import = round(trial_info.start_frame * qtm_data.Force(1).SamplingFactor);
    last_frame_to_import = round(trial_info.end_frame * qtm_data.Force(1).SamplingFactor);

    % Force data - data are in qtm_data.Force(n).Force
    force_plates_to_import = study_settings.get('force_plates_to_import', 1);
    if any(any(qtm_data.Force(force_plates_to_import(1)).Force))
        forceplate_tajectories_Left = ...
            [ ...
            qtm_data.Force(force_plates_to_import(1)).Force(:, first_frame_to_import : last_frame_to_import)', ...
            qtm_data.Force(force_plates_to_import(1)).Moment(:, first_frame_to_import : last_frame_to_import)' ...
            ];
        forceplate_tajectories_Right = ...
            [ ...
            qtm_data.Force(force_plates_to_import(2)).Force(:, first_frame_to_import : last_frame_to_import)', ...
            qtm_data.Force(force_plates_to_import(2)).Moment(:, first_frame_to_import : last_frame_to_import)' ...
            ];
        forceplate_raw_trajectories = [forceplate_tajectories_Left, forceplate_tajectories_Right];
    else % currently taking volts... need to scale accordinginly
        warning('No force data found, using analog data instead. This is currently not scaling correctly.')
        forceplate_raw_trajectories = [qtm_data.Analog.Data(1:12, this_trial_start_index : this_trial_end_index)]';
    end

    % check if the last data point is NaN for some reason and remove if necessary
    if any(isnan(forceplate_raw_trajectories(end, :))) & ~any(isnan(forceplate_raw_trajectories(end-1, :)))
        forceplate_raw_trajectories = forceplate_raw_trajectories(1:end-1, :);
    end

    % make labels
    forceplate_labels = qtm_data.Analog.Labels(1:12);
    forceplate_location_left = mean(qtm_data.Force(1).ForcePlateLocation) * options.millimeter_to_meter; % mean of corner coordinates gives center
    forceplate_location_right = mean(qtm_data.Force(2).ForcePlateLocation) * options.millimeter_to_meter; % mean of corner coordinates gives center

    sampling_rate_forceplate = qtm_data.Force(1).Frequency;
    time_forceplate = (1 : size(forceplate_raw_trajectories, 1))' / sampling_rate_forceplate;

    % make directions
    % NOTE: this defines directions and makes assumptions, make sure everything is right here
    forceplate_directions = cell(2, length(forceplate_labels));
    [forceplate_directions{1, [1 4 7 10]}] = deal('right');
    [forceplate_directions{2, [1 4 7 10]}] = deal('left');
    [forceplate_directions{1, [2 5 8 11]}] = deal('forward');
    [forceplate_directions{2, [2 5 8 11]}] = deal('backward');
    [forceplate_directions{1, [3 6 9 12]}] = deal('up');
    [forceplate_directions{2, [3 6 9 12]}] = deal('down');

    % save forceplate data
    save_folder = 'raw';
    save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'forceplateTrajectoriesRaw.mat');
    save ...
        ( ...
        [save_folder filesep save_file_name], ...
        'forceplate_raw_trajectories', ...
        'forceplate_labels', ...
        'time_forceplate', ...
        'sampling_rate_forceplate', ...
        'forceplate_location_left', ...
        'forceplate_location_right', ...
        'forceplate_directions' ...
        );
    addAvailableData('forceplate_raw_trajectories', 'time_forceplate', 'sampling_rate_forceplate', '_forceplate_labels', '_forceplate_directions', save_folder, save_file_name);
end

function importTrialDataMarker(qtm_data, trial_info, file_info, subject_settings, options)
    % figure out frames
    first_frame_to_import = round(trial_info.start_frame);
    last_frame_to_import = round(trial_info.end_frame);
    number_of_frames = last_frame_to_import - first_frame_to_import + 1;

    % get relevant data in QTM format (N x 3 x T), where N = number of markers, T = number of samples
    markers_temp = qtm_data.Trajectories.Labeled.Data(:, 1:3, first_frame_to_import:last_frame_to_import);
    marker_labels = qtm_data.Trajectories.Labeled.Labels;
    sampling_rate_mocap = qtm_data.FrameRate;
    time_mocap = (1 : number_of_frames)' / sampling_rate_mocap;

    % reformat to T x 3N
    marker_count = 1;
    marker_raw_trajectories = [];
    for i_marker = 1: size(markers_temp,1)
        this_marker = markers_temp(i_marker,:,:);
        marker_raw_trajectories(marker_count:marker_count+2,:) = reshape(this_marker, size(this_marker,2), size(this_marker,3)) * options.millimeter_to_meter; 
        marker_count = marker_count + 3;
    end
    marker_raw_trajectories = marker_raw_trajectories';


    % replace marker labels if necessary
    marker_label_replacement_map = subject_settings.get('marker_label_replacement_map', 1);
    for i_label = 1 : size(marker_label_replacement_map, 1)
        old_label = marker_label_replacement_map{i_label, 1};
        new_label = marker_label_replacement_map{i_label, 2};
        marker_labels{strcmp(marker_labels, old_label)} = new_label;
    end

    % triplicate labels
    marker_labels_loaded = marker_labels;
    number_of_markers = length(marker_labels_loaded);
    marker_labels = cell(3, number_of_markers);
    for i_marker = 1 : length(marker_labels)
        marker_labels{1, i_marker} = [marker_labels_loaded{i_marker} '_x'];
        marker_labels{2, i_marker} = [marker_labels_loaded{i_marker} '_y'];
        marker_labels{3, i_marker} = [marker_labels_loaded{i_marker} '_z'];
    end
    marker_labels = reshape(marker_labels, 1, number_of_markers*3);

    % make directions
    % NOTE: this defines directions and makes assumptions, make sure everything is right here
    number_of_marker_trajectories = size(marker_raw_trajectories, 2);
    marker_directions = cell(2, number_of_marker_trajectories);
    [marker_directions{1, 1 : 3 : number_of_marker_trajectories}] = deal('right');
    [marker_directions{2, 1 : 3 : number_of_marker_trajectories}] = deal('left');
    [marker_directions{1, 2 : 3 : number_of_marker_trajectories}] = deal('forward');
    [marker_directions{2, 2 : 3 : number_of_marker_trajectories}] = deal('backward');
    [marker_directions{1, 3 : 3 : number_of_marker_trajectories}] = deal('up');
    [marker_directions{2, 3 : 3 : number_of_marker_trajectories}] = deal('down');


    % save
    save_folder = 'raw';
    save_file_name = makeFileName(file_info.collection_date, file_info.subject_id, trial_info.trial_type, trial_info.trial_number, 'markerTrajectoriesRaw.mat');
    save ...
        ( ...
        [save_folder filesep save_file_name], ...
        'marker_raw_trajectories', ...
        'time_mocap', ...
        'sampling_rate_mocap', ...
        'marker_labels', ...
        'marker_directions' ...
        );
    addAvailableData('marker_raw_trajectories', 'time_mocap', 'sampling_rate_mocap', '_marker_labels', '_marker_directions', save_folder, save_file_name);
end

function offset = analogOffset()
    offset = ...
      [ ...
        0; ...
        -0.0317098627837868; ...
        -0.0355064291396836; ...
        -0.0383662432835923; ...
        -0.0407330287129284; ...
        -0.0417785032417743; ...
        -0.0414159429847061; ...
        -0.0417277364763837; ...
        -0.0412429925743254; ...
        -0.0388849311198740; ...
        -0.0363677844014454; ...
        -0.0350654941860018; ...
        -0.0371848832588526; ...
        -0.0339162265276105; ...
        -0.0308550321637160; ...
        -0.0258480019743690; ...
        -0.0227666814457557; ...
        -0.0199298398628880; ...
        -0.0173543278850836; ...
        -0.0132742999011271; ...
        -0.0106610228969846; ...
        -0.00936478599793489; ...
        -0.00473625185189075; ...
        -0.00257883532928460; ...
        -0.000572734957710708; ...
        0.00132398762374120; ...
        0.00347722371700066; ...
        0.00398356837392289; ...
        0.00599911144133358; ...
        0.00753927394536458; ...
        0.00753085203582149; ...
        0.00870865857276826; ...
        0.00853249776011822; ...
        0.00853628316823052; ...
        0.00788663034824477; ...
        0.00840332559286772; ...
        0.00815475542401511; ...
        0.00798220864381083; ...
        0.00709983160489891; ...
        0.00690247828238899; ...
        0.00643181355926981; ...
        0.00503683000999455; ...
        0.00413383944497703; ...
        0.00329203775458176; ...
        0.00242120802380175; ...
        0.00149387016846525; ...
        0.000821574193582642; ...
        0.000369138339894271; ...
        -0.000277877672783866; ...
        -0.00102545670460508; ...
        -0.00271989182455190; ...
        -0.00365981488830602; ...
        -0.00482093843100540; ...
        -0.00494539216657319; ...
        -0.00588487154153494; ...
        -0.00599837804270820; ...
        -0.00682649900498600; ...
        -0.00655203723933173; ...
        -0.00791718834077937; ...
        -0.00825049603177419; ...
        -0.00769935445543801; ...
        -0.00852675928681101; ...
        -0.00815403884460952; ...
        -0.00963015799901790; ...
        -0.00895956615075910; ...
        -0.00961831343282515; ...
        -0.00966309582918967; ...
        -0.00952247347543045; ...
        -0.00919973803649565; ...
        -0.00920595233365562; ...
        -0.00893583474366810; ...
        -0.00877341543027255; ...
        -0.00870756374502735; ...
        -0.00856975753089673; ...
        -0.00870519970119821; ...
        -0.00932097017889166; ...
        -0.00848747970298325; ...
        -0.00844678720233416; ...
        -0.00783984295034923; ...
        -0.00773505034545563; ...
        -0.00705187100005489; ...
        -0.00704416271013297; ...
        -0.00689469491530370; ...
        -0.00674065592462925; ...
        -0.00612953452561960; ...
        -0.00560228535979301; ...
        -0.00535692483822525; ...
        -0.00488826650123864; ...
        -0.00468637134357453; ...
        -0.00436269192422967; ...
        -0.00396357745781306; ...
        -0.00378863032705390; ...
        -0.00367707688493169; ...
        -0.00314717004448473; ...
        -0.00288107214429201; ...
        -0.00249950966782508; ...
        -0.00246150124316424; ...
        -0.00185530510153731; ...
        -0.00161144218362400; ...
        -0.00146637549603207; ...
        -0.00102024355158730; ...
        -0.000815409068261150; ...
        -0.000734256181997323; ...
        -0.000832852161098741; ...
        -0.000792806693304171; ...
        -0.000108319700746151; ...
        -0.000265702930942080; ...
        -0.000279534687805283; ...
        -0.000491790882055976; ...
        -0.000426932735417163; ...
        -0.00117144863524299; ...
        -0.00153105624076844; ...
        -0.000998698616601734; ...
        -0.000935137108814876; ...
        -0.000958296975685613; ...
        -0.00142491381875454; ...
        -0.00164261683167122; ...
        -0.00264091356187746; ...
        -0.00309681499754499; ...
        -0.00401206048587333; ...
        -0.00396441579734863; ...
        -0.00422148403188150; ...
        -0.00529833879784958; ...
        -0.00596774150663659; ...
        -0.00678126028756942; ...
        -0.00723620698253669; ...
        -0.00772259027777311; ...
        -0.00825504622265649; ...
        -0.00816044205792954; ...
        -0.00916009217047842; ...
        -0.00977628691772603; ...
        -0.0106469097669994; ...
        -0.0109333378042864; ...
        -0.0119922291978138; ...
        -0.0122519306587239; ...
        -0.0130286490528753; ...
        -0.0130401366798907; ...
        -0.0137444705007748; ...
        -0.0138314855721378; ...
        -0.0141161149084041; ...
        -0.0144106983101242; ...
        -0.0146721926696580; ...
        -0.0144676458229069; ...
        -0.0148205448241381; ...
        -0.0148786138861228; ...
        -0.0144537309394677; ...
        -0.0143732644422432; ...
        -0.0139970179820059; ...
        -0.0137701494310054; ...
        -0.0128238368055325; ...
        -0.0125910885262401; ...
        -0.0135005954160290; ...
        -0.0126732101628155; ...
        -0.0115996832421770; ...
        -0.0105618871208364; ...
        -0.00950531667495813; ...
        -0.00839970631782627; ...
        -0.00740346782180268; ...
        -0.00593091658393519; ...
        -0.00513883242166635; ...
        -0.00375714780028513; ...
        -0.00162831240730377; ...
        -0.000394209661337186; ...
        0.00243617559528087; ...
        0.00190042906742605; ...
        0.00386235131119417; ...
        0.00538588999007050; ...
        0.00703525654969717; ...
        0.00907773138043932; ...
        0.0108388384692422; ...
        0.0129475880893617; ...
        0.0138018623944065; ...
        0.0152044950641930; ...
        0.0162984264486976; ...
        0.0179685779542922; ...
        0.0188687694610845; ...
        0.0202168224764048; ...
        0.0208049101290397; ...
        0.0220546340257348; ...
        0.0223920981075532; ...
        0.0225321870361555; ...
        0.0229908094999018; ...
        0.0241814339901651; ...
        0.0240792613920782; ...
        0.0238237301350370; ...
        0.0233348590569662; ...
        0.0232842471463997; ...
        0.0227356714357168; ...
        0.0216668784253855; ...
        0.0215045626865980; ...
        0.0215450198313842; ...
        0.0203315176705363; ...
        0.0190577137879586; ...
        0.0179738315997273; ...
        0.0168931232604397; ...
        0.0156401403073261; ...
        0.0150204841270369; ...
        0.0147189566948640; ...
        0.0131844504728420; ...
        0.0123703604766217; ...
        0; ...
      ];
end


















  
